
<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>slothpy.core package &#8212; SlothPy 0.0.1 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=ac02cc09edc035673794" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=ac02cc09edc035673794" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=ac02cc09edc035673794" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=ac02cc09edc035673794" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=362ab14a" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=ac02cc09edc035673794" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=ac02cc09edc035673794" />
  <script src="_static/vendor/fontawesome/6.1.2/js/all.min.js?digest=ac02cc09edc035673794"></script>

    <script src="_static/documentation_options.js?v=f539c95a"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'slothpy.core';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="slothpy package" href="slothpy.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>

  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
<div class="bd-header__inner bd-page-width">
  <label class="sidebar-toggle primary-toggle" for="__primary">
    <span class="fa-solid fa-bars"></span>
  </label>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">
  

<a class="navbar-brand logo" href="index.html">
  
  
  
  
  
    <p class="title logo__title">SlothPy 0.0.1 documentation</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item"><nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item current active">
                      <a class="nav-link nav-internal" href="slothpy.html">
                        slothpy package
                      </a>
                    </li>
                
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          
 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
        </div>
      
      
        <div class="navbar-item">
<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">
 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
    </div>
  

  
    <label class="sidebar-toggle secondary-toggle" for="__secondary" tabindex="0">
      <span class="fa-solid fa-outdent"></span>
    </label>
  
</div>

    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          <div class="navbar-item"><nav class="navbar-nav">
  <p class="sidebar-header-items__title"
     role="heading"
     aria-level="1"
     aria-label="Site Navigation">
    Site Navigation
  </p>
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item current active">
                      <a class="nav-link nav-internal" href="slothpy.html">
                        slothpy package
                      </a>
                    </li>
                
  </ul>
</nav></div>
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">
<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
<h3><a href="index.html">Table of Contents</a></h3>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="slothpy.html">slothpy package</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="slothpy.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">slothpy.core package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-slothpy.core.compound_object">slothpy.core.compound_object module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-slothpy.core.creation_functions">slothpy.core.creation_functions module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-slothpy.core">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="slothpy.html#module-slothpy">Module contents</a></li>
</ul>
</li>
</ul>
</div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumb">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="slothpy.html" class="nav-link">slothpy package</a></li>
    
    <li class="breadcrumb-item active" aria-current="page">slothpy.core package</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section id="slothpy-core-package">
<h1>slothpy.core package<a class="headerlink" href="#slothpy-core-package" title="Link to this heading">#</a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading">#</a></h2>
</section>
<section id="module-slothpy.core.compound_object">
<span id="slothpy-core-compound-object-module"></span><h2>slothpy.core.compound_object module<a class="headerlink" href="#module-slothpy.core.compound_object" title="Link to this heading">#</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="slothpy.core.compound_object.Compound">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">slothpy.core.compound_object.</span></span><span class="sig-name descname"><span class="pre">Compound</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.compound_object.Compound" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The core object constituting the API and access to all the methods.</p>
<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.compound_object.Compound.delete_group_dataset">
<span class="sig-name descname"><span class="pre">delete_group_dataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.delete_group_dataset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.compound_object.Compound.delete_group_dataset" title="Link to this definition">#</a></dt>
<dd><p>Deletes a group/dataset provided its full name/path from the .slt file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>first</strong> (<em>str</em>) – A name of the gorup or dataset to be deleted.</p></li>
<li><p><strong>second</strong> (<em>str</em><em>, </em><em>optional</em>) – A name of the particular dataset inside the group from the first
argument to be deleted.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>SltFileError</strong> – If the deletion is unsuccessful.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.compound_object.Compound.calculate_g_tensor_and_axes_doublet">
<span class="sig-name descname"><span class="pre">calculate_g_tensor_and_axes_doublet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">doublets</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">int64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.calculate_g_tensor_and_axes_doublet"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.compound_object.Compound.calculate_g_tensor_and_axes_doublet" title="Link to this definition">#</a></dt>
<dd><p>Calculates pseudo-g-tensor components (for S = 1/2) and
main magnetic axes for a given list of doublet states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for the computation of g-tensors.</p></li>
<li><p><strong>doublets</strong> (<em>ndarray</em><em>[</em><em>int64</em><em>]</em>) – ArrayLike structure (can be converted to numpy.NDArray) of integers
corresponding to doublet labels (numbers).</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given, the results will be saved using this name to the .slt
file with the suffix: _g_tensors_axes, by default None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The first array (g_tensor_list) contains a list g-tensors in
a format [doublet_number, gx, gy, gz], the second one
(magnetic_axes_list) contains respective rotation matrices.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Tuple[ndarray[float64], ndarray[float64]]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltInputError</strong> – If input ArrayLike data cannot be converted to numpy.NDArrays.</p></li>
<li><p><strong>SltInputError</strong> – If doublets are not one-diemsional array.</p></li>
<li><p><strong>SltCompError</strong> – If the calculation of g-tensors is unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Magnetic axes are returned in the form of rotation matrices that
diagonalise the Abragam-Bleaney tensor (G = gg.T). Coordinates of the
main axes XYZ in the initial xzy frame are columns of such matrices
(0-X, 1-Y, 2-Z).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.compound_object.Compound.calculate_mth">
<span class="sig-name descname"><span class="pre">calculate_mth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fields</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperatures</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states_cutoff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_cpu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">autotune</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_autotune_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.calculate_mth"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.compound_object.Compound.calculate_mth" title="Link to this definition">#</a></dt>
<dd><p>Calculates powder-averaged or directional molar magnetisation M(T,H)
for a given list of temperature and field values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for the computation of the magnetisation.</p></li>
<li><p><strong>fields</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – ArrayLike structure (can be converted to numpy.NDArray) of field
values (T) at which magnetisation will be computed.</p></li>
<li><p><strong>grid</strong> (<em>Union</em><em>[</em><em>int</em><em>, </em><em>ndarray</em><em>[</em><em>float64</em><em>]</em><em>]</em>) – If the grid is set to an integer from 0-11 then the prescribed
Lebedev-Laikov grids over hemisphere will be used (see
grids_over_hemisphere documentation), otherwise, user can provide
an ArrayLike structure (can be converted to numpy.NDArray) with the
convention: [[direction_x, direction_y, direction_z, weight],…]
for powder-averaging. If one wants a calculation for a single,
particular direction the list has to contain one entry like this:
[[direction_x, direction_y, direction_z, 1.]]. Custom grids will be
automatically normalized.</p></li>
<li><p><strong>temperatures</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – ArrayLike structure (can be converted to numpy.NDArray) of
temeperature values (K) at which magnetisation will be computed.</p></li>
<li><p><strong>states_cutoff</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of states that will be taken into account for construction
of Zeeman Hamiltonian. If set to zero, all available states from
the file will be used., by default 0</p></li>
<li><p><strong>number_cpu</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of logical CPUs to be assigned to perform the calculation.
If set to zero, all available CPUs will be used., by default 0</p></li>
<li><p><strong>number_threads</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of threads used in a multithreaded implementation of linear
algebra libraries used during the calculation. Higher values
benefit from the increasing size of matrices (states_cutoff) over
the parallelization over CPUs., by default 1</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _magnetisation., by default None</p></li>
<li><p><strong>autotune</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True the program will automatically try to choose the best
number of threads (and therefore parallel processes), for the given
number of CPUs, to be used during the calculation. Note that this
process can take a significant amount of time, so start to use it
with medium-sized calculations (e.g. for states_cutoff &gt; 300 with
dense grids or a higher number of field values) where it becomes
a necessity., by default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting mth_array gives magnetisation in Bohr magnetons and
is in the form [temperatures, fields] - the first dimension runs
over temperature values, and the second over fields.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray[float64]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltInputError</strong> – If input ArrayLike data cannot be converted to numpy.NDArrays.</p></li>
<li><p><strong>SltInputError</strong> – If fields are not a one-diemsional array.</p></li>
<li><p><strong>SltInputError</strong> – If temperatures are not a one-diemsional array.</p></li>
<li><p><strong>SltCompError</strong> – If autotuning a number of processes and threads is unsuccessful.</p></li>
<li><p><strong>SltCompError</strong> – If the calculation of magnetisation is unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">slothpy.lebedev_laikov_grid</span></code></dt><dd><p>For the description of the prescribed</p>
</dd>
</dl>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Lebedev-Laikov</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>Here, (number_cpu // number_threads) parallel processes are used to
distribute the workload over the provided field values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.compound_object.Compound.calculate_mag_3d">
<span class="sig-name descname"><span class="pre">calculate_mag_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fields</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spherical_grid</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperatures</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states_cutoff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_cpu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">autotune</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_autotune_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.calculate_mag_3d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.compound_object.Compound.calculate_mag_3d" title="Link to this definition">#</a></dt>
<dd><p>Calculates 3D magnetisation over a spherical grid for a given list of
temperature and field values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for the computation of the 3D magnetisation.</p></li>
<li><p><strong>fields</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – ArrayLike structure (can be converted to numpy.NDArray) of field
values (T) at which 3D magnetisation will be computed.</p></li>
<li><p><strong>spherical_grid</strong> (<em>int</em>) – Controls the density of the angular grid for the 3D magnetisation
calculation. A grid of dimension (spherical_grid*2*spherical_grid)
for spherical angles theta [0, pi], and phi [0, 2*pi] will be used.</p></li>
<li><p><strong>temperatures</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – ArrayLike structure (can be converted to numpy.NDArray) of
temperature values (K) at which 3D magnetisation will be computed.</p></li>
<li><p><strong>states_cutoff</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of states that will be taken into account for construction
of Zeeman Hamiltonian. If set to zero, all available states from
the file will be used., by default 0</p></li>
<li><p><strong>number_cpu</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of logical CPUs to be assigned to perform the calculation.
If set to zero, all available CPUs will be used., by default 0</p></li>
<li><p><strong>number_threads</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of threads used in a multithreaded implementation of linear
algebra libraries used during the calculation. Higher values
benefit from the increasing size of matrices (states_cutoff) over
the parallelization over CPUs., by default 1</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _3d_magnetisation., by default None</p></li>
<li><p><strong>autotune</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True the program will automatically try to choose the best
number of threads (and therefore parallel processes), for the given
number of CPUs, to be used during the calculation. Note that this
process can take a significant amount of time, so start to use it
with medium-sized calculations (e.g. for states_cutoff &gt; 300 with
dense grids or a higher number of field values) where it becomes
a necessity., by default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting mag_3d_array gives magnetisation in Bohr magnetons
and is in the form [coordinates, fields, temperatures, mesh, mesh]
- the first dimension runs over coordinates (0-x, 1-y, 2-z), the
second over field values, and the third over temperatures. The last
two dimensions are in a form of meshgrids over theta and phi, ready
for 3D plots as xyz.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray[float64]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltInputError</strong> – If input ArrayLike data cannot be converted to numpy.NDArrays.</p></li>
<li><p><strong>SltInputError</strong> – If fields are not a one-diemsional array.</p></li>
<li><p><strong>SltInputError</strong> – If temperatures are not a one-diemsional array.</p></li>
<li><p><strong>SltInputError</strong> – If spherical_grid is not a positive integer.</p></li>
<li><p><strong>SltCompError</strong> – If autotuning a number of processes and threads is unsuccessful.</p></li>
<li><p><strong>SltCompError</strong> – If the calculation of 3D magnetisation is unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Here, (number_cpu // number_threads) parallel processes are used to
distribute the workload over len(fields)*2*shperical_grid**2 tasks. Be
aware that the resulting arrays and computations can quickly consume
much memory (e.g. for a calculation with 100 field values 1-10 T, 300
temperatures 1-300 K, and spherical_grid = 60, the resulting array will
take 3*100*300*2*60*60*8 bytes = 5.184 GB).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.compound_object.Compound.calculate_chitht">
<span class="sig-name descname"><span class="pre">calculate_chitht</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperatures</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fields</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_h</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states_cutoff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_cpu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exp</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">autotune</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_autotune_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.calculate_chitht"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.compound_object.Compound.calculate_chitht" title="Link to this definition">#</a></dt>
<dd><p>Calculates powder-averaged or directional molar magnetic susceptibility
chi(T)(H,T) for a given list of field and temperatures values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for the computation of the magnetisation.</p></li>
<li><p><strong>temperatures</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – ArrayLike structure (can be converted to numpy.NDArray) of
temeperature values (K) at which magnetic susceptibility will
be computed.</p></li>
<li><p><strong>fields</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – ArrayLike structure (can be converted to numpy.NDArray) of field
values (T) at which magnetic susceptibility will be computed.</p></li>
<li><p><strong>number_of_points</strong> (<em>int</em>) – Controls the number of points for numerical differentiation over
the magnetic field values using the finite difference method with
a symmetrical stencil. The total number of used points =
(2 * num_of_opints + 1), therefore 1 is a minimum value to obtain
the first derivative using 3 points - including the value at the
point at which the derivative is taken. In this regard, the value 0
triggers the experimentalist model for susceptibility.</p></li>
<li><p><strong>delta_h</strong> (<em>float64</em><em>, </em><em>optional</em>) – Value of field step used for numerical differentiation using finite
difference method. 0.0001 (T) = 1 Oe is recommended as a starting
point., by default 0.0001</p></li>
<li><p><strong>states_cutoff</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of states that will be taken into account for construction
of Zeeman Hamiltonian. If set to zero, all available states from
the file will be used., by default 0</p></li>
<li><p><strong>number_cpu</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of logical CPUs to be assigned to perform the calculation.
If set to zero, all available CPUs will be used., by default 0</p></li>
<li><p><strong>number_threads</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of threads used in a multithreaded implementation of linear
algebra libraries used during the calculation. Higher values
benefit from the increasing size of matrices (states_cutoff) over
the parallelization over CPUs., by default 1</p></li>
<li><p><strong>exp</strong> (<em>bool</em><em>, </em><em>optional</em>) – Turns on the experimentalist model for magnetic susceptibility.,
by default False</p></li>
<li><p><strong>T</strong> (<em>bool</em><em>, </em><em>optional</em>) – Results are returned as a product with temperature chiT(H,T).,
by default True</p></li>
<li><p><strong>grid</strong> (<em>Union</em><em>[</em><em>int</em><em>, </em><em>np.ndarray</em><em>[</em><em>float64</em><em>]</em><em>]</em><em>, </em><em>optional</em>) – If the grid is set to an integer from 0-11 then the prescribed
Lebedev-Laikov grids over the hemisphere will be used (see
grids_over_hemisphere documentation), otherwise, the user can
provide an ArrayLike structure (can be converted to numpy.NDArray)
with the convention: [[direction_x, direction_y, direction_z,
weight],…] for powder-averaging. If one wants a calculation for a
single, particular direction the list has to contain one entry like
this: [[direction_x, direction_y, direction_z, 1.]]. If not given
the average is taken over xyz directions, which is sufficient for a
second rank tensor. Custom grids will be automatically normalized.,
by default None</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _susceptibility., by default None</p></li>
<li><p><strong>autotune</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True the program will automatically try to choose the best
number of threads (and therefore parallel processes), for the given
number of CPUs, to be used during the calculation. Note that this
process can take a significant amount of time, so start to use it
with medium-sized calculations (e.g. for states_cutoff &gt; 300 with
a higher number of field values and number_of_points) where it
becomes a necessity., by default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting chitht_array gives magnetic susceptibility (or
product with temperature) in cm^3 (or * K) and is in the form
[fields, temperatures] - the first dimension runs over field
values, and the second over temperatures.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray[float64]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file</p></li>
<li><p><strong>SltInputError</strong> – If input ArrayLike data cannot be converted to numpy.NDArrays</p></li>
<li><p><strong>SltInputError</strong> – If temperatures are not a one-diemsional array.</p></li>
<li><p><strong>SltInputError</strong> – If fields are not a one-diemsional array.</p></li>
<li><p><strong>SltInputError</strong> – If the  number of points for finite difference method is not
    a possitive integer.</p></li>
<li><p><strong>SltInputError</strong> – If the field step for the finite difference method is not
    a possitive real number.</p></li>
<li><p><strong>SltCompError</strong> – If autotuning a number of processes and threads is unsuccessful.</p></li>
<li><p><strong>SltCompError</strong> – If the calculation of magnetic susceptibility is unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Here, (number_cpu // number_threads) parallel processes are used to
distribute the workload over fields.size*(2*number_of_points+1) tasks.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.compound_object.Compound.calculate_chit_tensorht">
<span class="sig-name descname"><span class="pre">calculate_chit_tensorht</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperatures</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fields</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_h</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states_cutoff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_cpu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exp</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">autotune</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_autotune_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.calculate_chit_tensorht"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.compound_object.Compound.calculate_chit_tensorht" title="Link to this definition">#</a></dt>
<dd><p>Calculates magnetic susceptibility chi(H,T) (Van Vleck) tensor for
a given list of field and temperature values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for the computation of the magnetisation.</p></li>
<li><p><strong>temperatures</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – ArrayLike structure (can be converted to numpy.NDArray) of
temeperature values (K) at which magnetic susceptibility tensor
will be computed.</p></li>
<li><p><strong>fields</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – ArrayLike structure (can be converted to numpy.NDArray) of field
values (T) at which magnetic susceptibility tensor will be
computed.</p></li>
<li><p><strong>number_of_points</strong> (<em>int</em>) – Controls the number of points for numerical differentiation over
the magnetic field values using the finite difference method with
a symmetrical stencil. The total number of used points =
(2 * num_of_opints + 1), therefore 1 is a minimum value to obtain
the first derivative using 3 points - including the value at the
point at which the derivative is taken. In this regard, the value 0
triggers the experimentalist model for susceptibility.</p></li>
<li><p><strong>delta_h</strong> (<em>float64</em><em>, </em><em>optional</em>) – Value of field step used for numerical differentiation using finite
difference method. 0.0001 (T) = 1 Oe is recommended as a starting
point., by default 0.0001,</p></li>
<li><p><strong>states_cutoff</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of states that will be taken into account for construction
of Zeeman Hamiltonian. If set to zero, all available states from
the file will be used., by default 0</p></li>
<li><p><strong>number_cpu</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of logical CPUs to be assigned to perform the calculation.
If set to zero, all available CPUs will be used., by default 0</p></li>
<li><p><strong>number_threads</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of threads used in a multithreaded implementation of linear
algebra libraries used during the calculation. Higher values
benefit from the increasing size of matrices (states_cutoff) over
the parallelization over CPUs., by default 1</p></li>
<li><p><strong>exp</strong> (<em>bool</em><em>, </em><em>optional</em>) – Turns on the experimentalist model for magnetic susceptibility.,
by default False</p></li>
<li><p><strong>T</strong> (<em>bool</em><em>, </em><em>optional</em>) – Results are returned as a product with temperature chiT(H,T).,
by default True</p></li>
<li><p><strong>rotation</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em><em>, </em><em>optional</em>) – A (3,3) orthogonal rotation matrix used to rotate momenta matrices.
Note that the inverse matrix has to be given to rotate the
reference frame instead., by default None</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _susceptibility_tensor., by default None</p></li>
<li><p><strong>autotune</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True the program will automatically try to choose the best
number of threads (and therefore parallel processes), for the given
number of CPUs, to be used during the calculation. Note that this
process can take a significant amount of time, so start to use it
with medium-sized calculations (e.g. for states_cutoff &gt; 500 with
a higher number of field values and number_of_points) where it
becomes a necessity., by default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting array gives magnetic susceptibility (Van Vleck)
tensors (or products with temperature) in cm^3 (or * K) and is in
the form [fields, temperatures, 3x3 tensor] - the first dimension
runs over field values, the second over temperatures, and the last
two accomodate 3x3 tensors.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray[float64]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file</p></li>
<li><p><strong>SltInputError</strong> – If input ArrayLike data cannot be converted to numpy.NDArrays</p></li>
<li><p><strong>SltInputError</strong> – If temperatures are not a one-diemsional array.</p></li>
<li><p><strong>SltInputError</strong> – If fields are not a one-diemsional array.</p></li>
<li><p><strong>SltInputError</strong> – If the  number of points for finite difference method is not
    a possitive integer</p></li>
<li><p><strong>SltInputError</strong> – If the field step for the finite difference method is not
    a possitive real number.</p></li>
<li><p><strong>SltCompError</strong> – If autotuning a number of processes and threads is unsuccessful.</p></li>
<li><p><strong>SltCompError</strong> – If the calculation of magnetic susceptibility tensor is
    unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Here, (number_cpu // number_threads) parallel processes are used to
distribute the workload over fields.size*(2*number_of_points+1) tasks.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.compound_object.Compound.calculate_chit_3d">
<span class="sig-name descname"><span class="pre">calculate_chit_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperatures</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fields</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spherical_grid</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_h</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states_cutoff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_cpu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exp</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">autotune</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_autotune_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.calculate_chit_3d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.compound_object.Compound.calculate_chit_3d" title="Link to this definition">#</a></dt>
<dd><p>Calculates 3D magnetic susceptibility over a spherical grid for a given
list of temperature and field values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for the computation of the 3D magnetic
susceptibility.</p></li>
<li><p><strong>temperatures</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – ArrayLike structure (can be converted to numpy.NDArray) of
temperature values (K) at which 3D magnetic susceptibility will be
computed.</p></li>
<li><p><strong>fields</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – ArrayLike structure (can be converted to numpy.NDArray) of field
values (T) at which 3D magnetic susceptibility will be computed.</p></li>
<li><p><strong>spherical_grid</strong> (<em>int</em>) – Controls the density of the angular grid for the 3D susceptibility
calculation. A grid of dimension (spherical_grid*2*spherical_grid)
for spherical angles theta [0, pi], and phi [0, 2*pi] will be used.</p></li>
<li><p><strong>number_of_points</strong> (<em>int</em>) – Controls the number of points for numerical differentiation over
the magnetic field values using the finite difference method with
a symmetrical stencil. The total number of used points =
(2 * num_of_opints + 1), therefore 1 is a minimum value to obtain
the first derivative using 3 points - including the value at the
point at which the derivative is taken. In this regard, the value 0
triggers the experimentalist model for susceptibility.</p></li>
<li><p><strong>delta_h</strong> (<em>float64</em><em>, </em><em>optional</em>) – Value of field step used for numerical differentiation using finite
difference method. 0.0001 (T) = 1 Oe is recommended as a starting
point., by default 0.0001</p></li>
<li><p><strong>states_cutoff</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of states that will be taken into account for construction
of Zeeman Hamiltonian. If set to zero, all available states from
the file will be used., by default 0</p></li>
<li><p><strong>number_cpu</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of logical CPUs to be assigned to perform the calculation.
If set to zero, all available CPUs will be used., by default 0</p></li>
<li><p><strong>number_threads</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of threads used in a multithreaded implementation of linear
algebra libraries used during the calculation. Higher values
benefit from the increasing size of matrices (states_cutoff) over
the parallelization over CPUs., by default 1</p></li>
<li><p><strong>exp</strong> (<em>bool</em><em>, </em><em>optional</em>) – Turns on the experimentalist model for magnetic susceptibility.,
by default False</p></li>
<li><p><strong>T</strong> (<em>bool</em><em>, </em><em>optional</em>) – Results are returned as a product with temperature chiT(H,T).,
by default True</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _3d_magnetisation., by default None</p></li>
<li><p><strong>autotune</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True the program will automatically try to choose the best
number of threads (and therefore parallel processes), for the given
number of CPUs, to be used during the calculation. Note that this
process can take a significant amount of time, so start to use it
with medium-sized calculations (e.g. for states_cutoff &gt; 300 with
dense grids or a higher number of field values) where it becomes
a necessity., by default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting chi_3d_array gives magnetic susceptibility (or
product with temperature) in cm^3 (or * K) and is in the form
[coordinates, fields, temperatures, mesh, mesh] - the first
dimension runs over coordinates (0-x, 1-y, 2-z), the second over
field values, and the third over temperatures. The last two
dimensions are in a form of meshgrids over theta and phi, ready
for 3D plots as xyz.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray[float64]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltInputError</strong> – If input ArrayLike data cannot be converted to numpy.NDArrays.</p></li>
<li><p><strong>SltInputError</strong> – If temperatures are not a one-diemsional array.</p></li>
<li><p><strong>SltInputError</strong> – If fields are not a one-diemsional array.</p></li>
<li><p><strong>SltInputError</strong> – If spherical_grid is not a positive integer.</p></li>
<li><p><strong>SltInputError</strong> – If the  number of points for finite difference method is not
    a possitive integer.</p></li>
<li><p><strong>SltInputError</strong> – If the field step for the finite difference method is not
    a possitive real number.</p></li>
<li><p><strong>SltCompError</strong> – If autotuning a number of processes and threads is unsuccessful.</p></li>
<li><p><strong>SltCompError</strong> – If the calculation of 3D magnetic susceptibility is unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Here, (number_cpu // number_threads) parallel processes are used to
distribute the workload over len(fields)*(2*number_of_points + 1)
<a href="#id1"><span class="problematic" id="id2">*</span></a>2*shperical_grid**2 tasks. Be aware that the resulting arrays and
computations can quickly consume much memory (e.g. for calculation with
100 field values 1-10 T, 300 temperatures 1-300 K, number_of_points=3,
and spherical_grid = 60, the intermediate array (before numerical
differentiation) will take 7*100*300*2*60*60*8 bytes = 12.096 GB).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.compound_object.Compound.calculate_hemholtz_energyth">
<span class="sig-name descname"><span class="pre">calculate_hemholtz_energyth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fields</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperatures</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states_cutoff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_cpu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">internal_energy</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">autotune</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_autotune_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.calculate_hemholtz_energyth"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.compound_object.Compound.calculate_hemholtz_energyth" title="Link to this definition">#</a></dt>
<dd><p>Calculates powder-averaged or directional Hemholtz (or internal) energy
for a given list of temperature and field values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for the computation of the energy.</p></li>
<li><p><strong>fields</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – ArrayLike structure (can be converted to numpy.NDArray) of field
values (T) at which energy will be computed.</p></li>
<li><p><strong>grid</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – If the grid is set to an integer from 0-11 then the prescribed
Lebedev-Laikov grids over hemisphere will be used (see
grids_over_hemisphere documentation), otherwise, user can provide
an ArrayLike structure (can be converted to numpy.NDArray) with the
convention: [[direction_x, direction_y, direction_z, weight],…]
for powder-averaging. If one wants a calculation for a single,
particular direction the list has to contain one entry like this:
[[direction_x, direction_y, direction_z, 1.]]. Custom grids will be
automatically normalized.</p></li>
<li><p><strong>temperatures</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – ArrayLike structure (can be converted to numpy.NDArray) of
temeperature values (K) at which energy will be computed</p></li>
<li><p><strong>states_cutoff</strong> (<em>int</em>) – Number of states that will be taken into account for construction
of Zeeman Hamiltonian. If set to zero, all available states from
the file will be used., by default 0</p></li>
<li><p><strong>number_cpu</strong> (<em>int</em>) – Number of logical CPUs to be assigned to perform the calculation.
If set to zero, all available CPUs will be used., by default 0</p></li>
<li><p><strong>number_threads</strong> (<em>int</em>) – Number of threads used in a multithreaded implementation of linear
algebra libraries used during the calculation. Higher values
benefit from the increasing size of matrices (states_cutoff) over
the parallelization over CPUs., by default 1</p></li>
<li><p><strong>internal_energy</strong> (<em>bool</em><em>, </em><em>optional</em>) – Turns on the calculation of internal energy., by default False</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _hemholtz_energy or _internal_energy., by default
None</p></li>
<li><p><strong>autotune</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True the program will automatically try to choose the best
number of threads (and therefore parallel processes), for the given
number of CPUs, to be used during the calculation. Note that this
process can take a significant amount of time, so start to use it
with medium-sized calculations (e.g. for states_cutoff &gt; 300 with
dense grids or a higher number of field values) where it becomes
a necessity., by default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting eth_array gives energy in cm-1 and is in the form
[temperatures, fields] - the first dimension runs over temperature
values, and the second over fields.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray[float64]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltInputError</strong> – If input ArrayLike data cannot be converted to numpy.NDArrays.</p></li>
<li><p><strong>SltInputError</strong> – If fields are not a one-diemsional array</p></li>
<li><p><strong>SltInputError</strong> – If temperatures are not a one-diemsional array</p></li>
<li><p><strong>SltCompError</strong> – If autotuning a number of processes and threads is unsuccessful.</p></li>
<li><p><strong>SltCompError</strong> – If the calculation of energy is unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">slothpy.lebedev_laikov_grid</span></code></dt><dd><p>For the description of the prescribed</p>
</dd>
</dl>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Lebedev-Laikov</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>Here, (number_cpu // number_threads) parallel processes are used to
distribute the workload over the provided field values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.compound_object.Compound.calculate_hemholtz_energy_3d">
<span class="sig-name descname"><span class="pre">calculate_hemholtz_energy_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fields</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spherical_grid</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperatures</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states_cutoff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_cpu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">internal_energy</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">autotune</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_autotune_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.calculate_hemholtz_energy_3d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.compound_object.Compound.calculate_hemholtz_energy_3d" title="Link to this definition">#</a></dt>
<dd><p>Calculates 3D Hemholtz (or internal) energy over a spherical grid for
a given list of temperature and field values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for the computation of the 3D energy.</p></li>
<li><p><strong>fields</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – ArrayLike structure (can be converted to numpy.NDArray) of field
values (T) at which 3D energy will be computed.</p></li>
<li><p><strong>spherical_grid</strong> (<em>int</em>) – Controls the density of the angular grid for the 3D magnetisation
calculation. A grid of dimension (spherical_grid*2*spherical_grid)
for spherical angles theta [0, pi], and phi [0, 2*pi] will be used.</p></li>
<li><p><strong>temperatures</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – ArrayLike structure (can be converted to numpy.NDArray) of
temperature values (K) at which 3D energy will be computed.</p></li>
<li><p><strong>states_cutoff</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of states that will be taken into account for construction
of Zeeman Hamiltonian. If set to zero, all available states from
the file will be used., by default 0,</p></li>
<li><p><strong>number_cpu</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of logical CPUs to be assigned to perform the calculation.
If set to zero, all available CPUs will be used., by default 0</p></li>
<li><p><strong>number_threads</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of threads used in a multithreaded implementation of linear
algebra libraries used during the calculation. Higher values
benefit from the increasing size of matrices (states_cutoff) over
the parallelization over CPUs., by default 1</p></li>
<li><p><strong>internal_energy</strong> (<em>bool</em><em>, </em><em>optional</em>) – Turns on the calculation of internal energy., by default False</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _3d_hemholtz_energy or _3d_internal_energy.,
by default None</p></li>
<li><p><strong>autotune</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True the program will automatically try to choose the best
number of threads (and therefore parallel processes), for the given
number of CPUs, to be used during the calculation. Note that this
process can take a significant amount of time, so start to use it
with medium-sized calculations (e.g. for states_cutoff &gt; 300 with
dense grids or a higher number of field values) where it becomes
a necessity., by default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting energy_3d_array gives energy in cm-1
and is in the form [coordinates, fields, temperatures, mesh, mesh]
- the first dimension runs over coordinates (0-x, 1-y, 2-z), the
second over field values, and the third over temperatures. The last
two dimensions are in a form of meshgrids over theta and phi, ready
for 3D plots as xyz.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray[float64]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltInputError</strong> – If input ArrayLike data cannot be converted to numpy.NDArrays.</p></li>
<li><p><strong>SltInputError</strong> – If fields are not a one-diemsional array.</p></li>
<li><p><strong>SltInputError</strong> – If temperatures are not a one-diemsional array.</p></li>
<li><p><strong>SltInputError</strong> – If spherical_grid is not a positive integer.</p></li>
<li><p><strong>SltCompError</strong> – If autotuning a number of processes and threads is unsuccessful.</p></li>
<li><p><strong>SltCompError</strong> – If the calculation of 3D energy is unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Here, (number_cpu // number_threads) parallel processes are used to
distribute the workload over len(fields)*2*shperical_grid**2 tasks. Be
aware that the resulting arrays and computations can quickly consume
much memory (e.g. for a calculation with 100 field values 1-10 T, 300
temperatures 1-300 K, and spherical_grid = 60, the resulting array will
take 3*100*300*2*60*60*8 bytes = 5.184 GB).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.compound_object.Compound.calculate_zeeman_splitting">
<span class="sig-name descname"><span class="pre">calculate_zeeman_splitting</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_states</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fields</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states_cutoff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_cpu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">average</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">autotune</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_autotune_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.calculate_zeeman_splitting"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.compound_object.Compound.calculate_zeeman_splitting" title="Link to this definition">#</a></dt>
<dd><p>Calculates directional or powder-averaged Zeeman splitting for a given
number of states and list of field values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for the computation of the Zeeman splitting.</p></li>
<li><p><strong>number_of_states</strong> (<em>int</em>) – Number of states whose energy splitting will be given in the
result array.</p></li>
<li><p><strong>fields</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – ArrayLike structure (can be converted to numpy.NDArray) of field
values (T) at which Zeeman splitting will be computed.</p></li>
<li><p><strong>grid</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – If the grid is set to an integer from 0-11 then the prescribed
Lebedev-Laikov grids over hemisphere will be used (see
grids_over_hemisphere documentation) and powder-averaging will be
turned on, otherwise, user can provide an ArrayLike structure (can
be converted to numpy.NDArray) with the convention: [[direction_x,
direction_y, direction_z, weight],…] with average = True for
powder-averaging. If one wants a calculation for a list of
particular directions the list has to follow the format:
[[direction_x, direction_y, direction_z],…]. Custom grids will be
automatically normalized.</p></li>
<li><p><strong>states_cutoff</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of states that will be taken into account for construction
of Zeeman Hamiltonian. If set to zero, all available states from
the file will be used., by default 0</p></li>
<li><p><strong>number_cpu</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of logical CPUs to be assigned to perform the calculation.
If set to zero, all available CPUs will be used., by default 0</p></li>
<li><p><strong>number_threads</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of threads used in a multithreaded implementation of linear
algebra libraries used during the calculation. Higher values
benefit from the increasing size of matrices (states_cutoff) over
the parallelization over CPUs., by default 1</p></li>
<li><p><strong>average</strong> (<em>bool</em><em>, </em><em>optional</em>) – Turns on powder-averaging using a list of directions and weights in
the form of ArrayLike structure: [[direction_x, direction_y,
direction_z, weight],…].</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _zeeman_splitting., by default None</p></li>
<li><p><strong>autotune</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True the program will automatically try to choose the best
number of threads (and therefore parallel processes), for the given
number of CPUs, to be used during the calculation. Note that this
process can take a significant amount of time, so start to use it
with medium-sized calculations (e.g. for states_cutoff &gt; 300 with
dense grids or a higher number of field values) where it becomes
a necessity., by default Falsee</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting array gives Zeeman splitting of number_of_states
energy levels in cm-1 for each direction (or average) in the form
[orientations, fields, energies] - the first dimension
runs over different orientations, the second over field values, and
the last gives energy of number_of_states states.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray[float64]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltInputError</strong> – If input ArrayLike data cannot be converted to numpy.NDArrays.</p></li>
<li><p><strong>SltInputError</strong> – If fields are not a one-diemsional array.</p></li>
<li><p><strong>SltInputError</strong> – If number of states is not a positive integer less or equal to the
    states cutoff.</p></li>
<li><p><strong>SltCompError</strong> – If autotuning a number of processes and threads is unsuccessful.</p></li>
<li><p><strong>SltCompError</strong> – If the calculation of Zeeman splitting is unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">slothpy.lebedev_laikov_grid</span></code></dt><dd><p>For the description of the prescribed</p>
</dd>
</dl>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Lebedev-Laikov</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>Here, (number_cpu // number_threads) parallel processes are used to
distribute the workload over the provided field values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.compound_object.Compound.zeeman_matrix">
<span class="sig-name descname"><span class="pre">zeeman_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states_cutoff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fields</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientations</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">complex128</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.zeeman_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.compound_object.Compound.zeeman_matrix" title="Link to this definition">#</a></dt>
<dd><p>Calculates Zeeman matrices for a given list of magnetic fields and
their orientations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for the computation of the Zeeman matrices.</p></li>
<li><p><strong>states_cutoff</strong> (<em>int</em>) – Number of states that will be taken into account for construction
of Zeeman Hamiltonian. If set to zero, all available states from
the file will be used., by default 0</p></li>
<li><p><strong>fields</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – ArrayLike structure (can be converted to numpy.NDArray) of field
values (T) for which Zeeman matrices will be computed.</p></li>
<li><p><strong>orientations</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – List (ArrayLike structure) of particular magnetic field directions
for which Zeeman matrices will be constructed. The list has to
follow the format: [[direction_x, direction_y, direction_z],…].
The vectors will be automatically normalized.</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _zeeman_matrix., by default None</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting array gives Zeeman matrices for each field value and
orientation in the form [fields, orientations, matrix, matrix] in
atomic units a.u. (Hartree).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray[complex128]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltInputError</strong> – If input ArrayLike data cannot be converted to numpy.NDArrays.</p></li>
<li><p><strong>SltInputError</strong> – If fields are not a one-diemsional array.</p></li>
<li><p><strong>SltCompError</strong> – If the calculation of Zeeman matrices is unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.compound_object.Compound.soc_energies_cm_1">
<span class="sig-name descname"><span class="pre">soc_energies_cm_1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_states</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.soc_energies_cm_1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.compound_object.Compound.soc_energies_cm_1" title="Link to this definition">#</a></dt>
<dd><p>Returns energies for the given number of first spin-orbit
states in cm-1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations.</p></li>
<li><p><strong>number_of_states</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of states whose energy will be returned. If set to zero, all
available states will be inculded., by default 0</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _soc_energies., by default None</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting array is one-dimensional and contains the energy of
first number_of_states states in cm-1.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray[float64]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltReadError</strong> – If the program is unable to get SOC energies from the .slt file.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.compound_object.Compound.states_magnetic_momenta">
<span class="sig-name descname"><span class="pre">states_magnetic_momenta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.states_magnetic_momenta"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.compound_object.Compound.states_magnetic_momenta" title="Link to this definition">#</a></dt>
<dd><p>Calculates magnetic momenta of a given list (or number) of SOC states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for the computation of the magnetic momenta.</p></li>
<li><p><strong>states</strong> (<em>Union</em><em>[</em><em>int</em><em>, </em><em>np.ndarray</em><em>[</em><em>int</em><em>]</em><em>]</em><em>, </em><em>optional</em>) – ArrayLike structure (can be converted to numpy.NDArray) of
states indexes for which magnetic momenta will be calculated. If
set to an integer it acts as a states cutoff (first n states will
be given). For all available states set it to zero., by default 0</p></li>
<li><p><strong>rotation</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em><em>, </em><em>optional</em>) – A (3,3) orthogonal rotation matrix used to rotate momenta matrices.
Note that the inverse matrix has to be given to rotate the
reference frame instead., by default None</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _states_magnetic_momenta., by default None</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting array is one-dimensional and contains the magnetic
momenta corresponding to the given states indexes in atomic units.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray[float64]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltInputError</strong> – If input ArrayLike data cannot be converted to numpy.NDArrays.</p></li>
<li><p><strong>SltCompError</strong> – If the calculation of magnetic momenta is unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.compound_object.Compound.states_total_angular_momenta">
<span class="sig-name descname"><span class="pre">states_total_angular_momenta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.states_total_angular_momenta"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.compound_object.Compound.states_total_angular_momenta" title="Link to this definition">#</a></dt>
<dd><p>Calculates total angular momenta of a given list (or number) of SOC
states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for the computation of the magnetic momenta.</p></li>
<li><p><strong>states</strong> (<em>Union</em><em>[</em><em>int</em><em>, </em><em>np.ndarray</em><em>[</em><em>int</em><em>]</em><em>]</em><em>, </em><em>optional</em>) – ArrayLike structure (can be converted to numpy.NDArray) of
states indexes for which total angular momenta will be calculated.
If set to an integer it acts as a states cutoff (first n states
will be given). For all available states set it to zero.
, by default 0</p></li>
<li><p><strong>rotation</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em><em>, </em><em>optional</em>) – A (3,3) orthogonal rotation matrix used to rotate momenta matrices.
Note that the inverse matrix has to be given to rotate the
reference frame instead., by default None</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _states_total_angular_momenta., by default None</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting array is one-dimensional and contains the total
angular momenta corresponding to the given states indexes in atomic
units.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray[float64]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltInputError</strong> – If input ArrayLike data cannot be converted to numpy.NDArrays.</p></li>
<li><p><strong>SltCompError</strong> – If the calculation of total angular momenta is unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.compound_object.Compound.magnetic_momenta_matrix">
<span class="sig-name descname"><span class="pre">magnetic_momenta_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states_cutoff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">complex128</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.magnetic_momenta_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.compound_object.Compound.magnetic_momenta_matrix" title="Link to this definition">#</a></dt>
<dd><p>Calculates magnetic momenta matrix for a given number of SOC states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for the computation of the magnetic momenta
matrix.</p></li>
<li><p><strong>states_cutoff</strong> (<em>np.ndarray</em><em>, </em><em>optional</em>) – Number of states that will be taken into account for construction
of the magnetic momenta matrix. If set to zero, all available
states from the file will be included., by default 0</p></li>
<li><p><strong>rotation</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em><em>, </em><em>optional</em>) – A (3,3) orthogonal rotation matrix used to rotate momenta matrices.
Note that the inverse matrix has to be given to rotate the
reference frame instead., by default None</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _magnetic_momenta_matrix., by default None</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting magnetic_momenta_matrix_array gives magnetic momenta
in atomic units and is in the form [coordinates, matrix, matrix]
- the first dimension runs over coordinates (0-x, 1-y, 2-z).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray[complex128]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltCompError</strong> – If the calculation of magetic momenta matrix is unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.compound_object.Compound.total_angular_momenta_matrix">
<span class="sig-name descname"><span class="pre">total_angular_momenta_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states_cutoff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">complex128</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.total_angular_momenta_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.compound_object.Compound.total_angular_momenta_matrix" title="Link to this definition">#</a></dt>
<dd><p>Calculates total angular momenta matrix for a given number of SOC
states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for the computation of the total angular momenta
matrix.</p></li>
<li><p><strong>states_cutoff</strong> (<em>np.ndarray</em><em>, </em><em>optional</em>) – Number of states that will be taken into account for construction
of the total angular momenta matrix. If set to zero, all available
states from the file will be included., by default 0</p></li>
<li><p><strong>rotation</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em><em>, </em><em>optional</em>) – A (3,3) orthogonal rotation matrix used to rotate momenta matrices.
Note that the inverse matrix has to be given to rotate the
reference frame instead., by default None</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _total angular_momenta_matrix., by default None</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting total_angular_momenta_matrix_array gives total
angular momenta in atomic units and is in the form [coordinates,
matrix, matrix] - the first dimension runs over coordinates
(0-x, 1-y, 2-z).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray[complex128]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltCompError</strong> – If the calculation of total angular momenta matrix is unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.compound_object.Compound.matrix_decomposition_in_z_pseudo_spin_basis">
<span class="sig-name descname"><span class="pre">matrix_decomposition_in_z_pseudo_spin_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">soc</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">zeeman</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pseudo_kind</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">magnetic</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">total_angular</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float64</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.matrix_decomposition_in_z_pseudo_spin_basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.compound_object.Compound.matrix_decomposition_in_z_pseudo_spin_basis" title="Link to this definition">#</a></dt>
<dd><p>Calculates decomposition of a given matrix in “z” pseudo-spin basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for the construction of the matrix.</p></li>
<li><p><strong>matrix</strong> (<em>Union</em><em>[</em><em>&quot;soc&quot;</em><em>, </em><em>&quot;zeeman&quot;</em><em>]</em>) – Type of a matrix to be decomposed. Two options available: “soc” or
“zeeman”.</p></li>
<li><p><strong>pseudo_kind</strong> (<em>Union</em><em>[</em><em>&quot;magnetic&quot;</em><em>, </em><em>&quot;total_angular&quot;</em><em>]</em>) – Kind of a pseudo-spin basis. Two options available: “magnetic” or
“total_angular” for the decomposition in a particular basis.</p></li>
<li><p><strong>start_state</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of the first SOC state to be included., by default 0</p></li>
<li><p><strong>stop_state</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of the last SOC state to be included. If both start and stop
are set to zero all available states from the file will be used.
, by default 0</p></li>
<li><p><strong>rotation</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em><em>, </em><em>optional</em>) – A (3,3) orthogonal rotation matrix used to rotate momenta matrices.
Note that the inverse matrix has to be given to rotate the
reference frame instead., by default None</p></li>
<li><p><strong>field</strong> (<em>float64</em><em>, </em><em>optional</em>) – If matrix type = “zeeman” it controls a magnetic field value at
which Zeman matrix will be computed., by default None</p></li>
<li><p><strong>orientation</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em><em>, </em><em>optional</em>) – If matrix type = “zeeman” it controls the orientation of the
magnetic field and has to be in the form [direction_x, direction_y,
direction_z] and be an ArrayLike structure (can be converted to
numpy.NDArray)., by default None</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _magnetic/total_angular_decomposition.
, by default None</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting array gives decomposition in % where rows are
SOC/Zeeman states and columns are associated with pseudo spin basis
(from -Sz to Sz).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray[float64]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltCompError</strong> – If the decomposition of the matrix is unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.compound_object.Compound.soc_crystal_field_parameters">
<span class="sig-name descname"><span class="pre">soc_crystal_field_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pseudo_kind</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">magnetic</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">total_angular</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">even_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">complex</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.soc_crystal_field_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.compound_object.Compound.soc_crystal_field_parameters" title="Link to this definition">#</a></dt>
<dd><p>Calculates ITO decomposition (CFPs) of SOC matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for obtaining the SOC matrix.</p></li>
<li><p><strong>start_state</strong> (<em>int</em>) – Number of the first SOC state to be included.</p></li>
<li><p><strong>stop_state</strong> (<em>int</em>) – Number of the last SOC state to be included. If both start and stop
are set to zero all available states from the file will be used.</p></li>
<li><p><strong>order</strong> (<em>int</em>) – Order of the highest ITO (CFP) to be included in the decomposition.</p></li>
<li><p><strong>pseudo_kind</strong> (<em>Union</em><em>[</em><em>&quot;magnetic&quot;</em><em>, </em><em>&quot;total_angular&quot;</em><em>]</em>) – Kind of a pseudo-spin basis. Two options available: “magnetic” or
“total_angular” for the decomposition in a particular basis.</p></li>
<li><p><strong>even_order</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, only even order ITOs (CFPs) will be included in the
decomposition., by default True</p></li>
<li><p><strong>complex</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, instead of real ITOs (CFPs) complex ones will be given.,
by default False</p></li>
<li><p><strong>rotation</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em><em>, </em><em>optional</em>) – A (3,3) orthogonal rotation matrix used to rotate momenta matrices.
Note that the inverse matrix has to be given to rotate the
reference frame instead., by default None</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _soc_ito_decomposition., by default None</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting list gives CFP - B_k_q (ITO) in the form [k,q,B_k_q].</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltReadError</strong> – If the program is unable to read SOC matrix from the file.</p></li>
<li><p><strong>SltInputError</strong> – If the order exceeds 2S pseudo-spin value.</p></li>
<li><p><strong>SltCompError</strong> – If the ITO decomposition of the matrix is unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.compound_object.Compound.zeeman_matrix_ito_decpomosition">
<span class="sig-name descname"><span class="pre">zeeman_matrix_ito_decpomosition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pseudo_kind</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">magnetic</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">total_angular</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">complex</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.zeeman_matrix_ito_decpomosition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.compound_object.Compound.zeeman_matrix_ito_decpomosition" title="Link to this definition">#</a></dt>
<dd><p>Calculates ITO decomposition of Zeeman matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for obtaining the Zeeman matrix.</p></li>
<li><p><strong>start_state</strong> (<em>int</em>) – Number of the first Zeeman state to be included.</p></li>
<li><p><strong>stop_state</strong> (<em>int</em>) – Number of the last Zeeman state to be included. If both start and
stop are set to zero all available states from the file will be
used.</p></li>
<li><p><strong>field</strong> (<em>float64</em>) – Magnetic field value at which Zeman matrix will be computed.</p></li>
<li><p><strong>orientation</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – Orientation of the magnetic field in the form of an ArrayLike
structure (can be converted to numpy.NDArray) [direction_x,
direction_y, direction_z].</p></li>
<li><p><strong>order</strong> (<em>int</em>) – Order of the highest ITO (CFP) to be included in the decomposition.</p></li>
<li><p><strong>pseudo_kind</strong> (<em>Union</em><em>[</em><em>&quot;magnetic&quot;</em><em>, </em><em>&quot;total_angular&quot;</em><em>]</em>) – Kind of a pseudo-spin basis. Two options available: “magnetic” or
“total_angular” for the decomposition in a particular basis.</p></li>
<li><p><strong>complex</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, instead of real ITOs (CFPs) complex ones will be given.,
by default False</p></li>
<li><p><strong>rotation</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em><em>, </em><em>optional</em>) – A (3,3) orthogonal rotation matrix used to rotate momenta matrices.
Note that the inverse matrix has to be given to rotate the
reference frame instead., by default None</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _zeeman_ito_decomposition., by default None</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting list gives ITOs - B_k_q in the form [k,q,B_k_q]</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltCompError</strong> – If the program is unable to calculate Zeeman matrix from the file.</p></li>
<li><p><strong>SltInputError</strong> – If the order exceeds 2S pseudo-spin value</p></li>
<li><p><strong>SltCompError</strong> – If the ITO decomposition of the matrix is unsuccessful</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.compound_object.Compound.matrix_from_ito">
<span class="sig-name descname"><span class="pre">matrix_from_ito</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">full_group_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">complex</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dataset_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pseudo_spin</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float64</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">complex128</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.matrix_from_ito"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.compound_object.Compound.matrix_from_ito" title="Link to this definition">#</a></dt>
<dd><p>Calculates matrix from a given ITO decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>full_group_name</strong> (<em>str</em>) – Full name of a group containing ITO decomposition.</p></li>
<li><p><strong>complex</strong> (<em>bool</em>) – Determines the type of ITOs in the dataset. If True, instead of
real ITOs complex ones will be used., by default False</p></li>
<li><p><strong>dataset_name</strong> (<em>str</em><em>, </em><em>optional</em>) – A custom name for a user-created dataset within the group that
contains list of B_k_q parameters in the form [k,q,B_k_q].,
by default None</p></li>
<li><p><strong>pseudo_spin</strong> (<em>float64</em><em>, </em><em>optional</em>) – Pseudo spin S value for the user-defined dataset., by default None</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _matrix_from_ito., by default None</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Matrix reconstructed from a given ITO list.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray[complex128]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltCompError</strong> – If the calculation of the matrix from ITOs is unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.compound_object.Compound.soc_zeem_in_z_angular_magnetic_momentum_basis">
<span class="sig-name descname"><span class="pre">soc_zeem_in_z_angular_magnetic_momentum_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrix_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">soc</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">zeeman</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis_kind</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">magnetic</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">total_angular</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float64</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">complex128</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.soc_zeem_in_z_angular_magnetic_momentum_basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.compound_object.Compound.soc_zeem_in_z_angular_magnetic_momentum_basis" title="Link to this definition">#</a></dt>
<dd><p>Calculates SOC or Zeeman matrix in “z” magnetic or total angular
momentum basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for obtaining the SOC or Zeeman matrix.</p></li>
<li><p><strong>start_state</strong> (<em>int</em>) – Number of the first SOC state to be included.</p></li>
<li><p><strong>stop_state</strong> (<em>int</em>) – Number of the last SOC state to be included. If both start and stop
are set to zero all available states from the file will be used</p></li>
<li><p><strong>matrix_type</strong> (<em>Union</em><em>[</em><em>&quot;soc&quot;</em><em>, </em><em>&quot;zeeman&quot;</em><em>]</em>) – Type of a matrix to be decomposed. Two options available: “soc” or
“zeeman”.</p></li>
<li><p><strong>basis_kind</strong> (<em>Union</em><em>[</em><em>&quot;magnetic&quot;</em><em>, </em><em>&quot;total_angular&quot;</em><em>]</em>) – Kind of a basis. Two options available: “magnetic” or
“total_angular” for the decomposition in a particular basis</p></li>
<li><p><strong>rotation</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em><em>, </em><em>optional</em>) – A (3,3) orthogonal rotation matrix used to rotate momenta matrices.
Note that the inverse matrix has to be given to rotate the
reference frame instead., by default None</p></li>
<li><p><strong>field</strong> (<em>float64</em><em>, </em><em>optional</em>) – _description_, by default None</p></li>
<li><p><strong>orientation</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em><em>, </em><em>optional</em>) – Orientation of the magnetic field in the form of an ArrayLike
structure (can be converted to numpy.NDArray) [direction_x,
direction_y, direction_z]., by default None</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _{matrix_type}_matrix_in_{basis_kind}_basis.,
by default None</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Matrix in a given kind of basis.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray[complex128]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltInputError</strong> – If an unsuported type of matrix or basis is provided.</p></li>
<li><p><strong>SltInputError</strong> – If there is no field value or orientation provided for Zeeman
    matrix.</p></li>
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltCompError</strong> – If the calculation of a matrix in “z” basis is unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.compound_object.Compound.colour_map">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">colour_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.colour_map"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.compound_object.Compound.colour_map" title="Link to this definition">#</a></dt>
<dd><p>Creates matplotlib colour map object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> – (str or lst) one of defined names for colour maps: BuPi, rainbow, dark_rainbow, light_rainbow,</p></li>
<li><p><strong>light_rainbow_alt</strong> – </p></li>
<li><p><strong>BuOr</strong> – </p></li>
<li><p><strong>BuYl</strong> – </p></li>
<li><p><strong>BuRd</strong> – </p></li>
<li><p><strong>GnYl</strong> – </p></li>
<li><p><strong>PrOr</strong> – </p></li>
<li><p><strong>GnRd</strong> – </p></li>
<li><p><strong>funmat</strong> – </p></li>
<li><p><strong>NdCoN322bpdo</strong> – </p></li>
<li><p><strong>NdCoNO222bpdo</strong> – </p></li>
<li><p><strong>NdCoI22bpdo</strong> – </p></li>
</ul>
</dd>
</dl>
<p>:param :
:param viridis:
:param plasma:
:param inferno:
:param magma:
:param cividis or list of colour from which colour map will be created by:
:param interpolation of colours between ones on a list; for predefined names modifiers can be applyed: _l loops
:param the list in a way that it starts and ends with the same colour:
:param _r reverses the list:</p>
<p>Returns:</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.compound_object.Compound.custom_colour_cycler">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">custom_colour_cycler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">number_of_colours</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.custom_colour_cycler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.compound_object.Compound.custom_colour_cycler" title="Link to this definition">#</a></dt>
<dd><p>Creates colour cycler from two colour maps in alternating pattern, suitable for use in matplotlib plots.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>number_of_colours</strong> – (int) number of colour in cycle</p></li>
<li><p><strong>cmap1</strong> – (str or lst) colour map name or list of colours (valid input for Compoud.colour_map())</p></li>
<li><p><strong>cmap2</strong> – (str or lst) colour map name or list of colours (valid input for Compoud.colour_map())</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>cycler object created based on two input colourmaps</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.compound_object.Compound.plot_mth">
<span class="sig-name descname"><span class="pre">plot_mth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colour_map_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'rainbow'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xticks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yticks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'B'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.plot_mth"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.compound_object.Compound.plot_mth" title="Link to this definition">#</a></dt>
<dd><p>Function that creates graphs of M(H,T) given name of the group in HDF5 file, graphs can be optionally shown,
saved, colour palettes can be changed. If origin=True it returns data packed into a dictionary for exporting
to Origin.</p>
<blockquote>
<div><dl class="simple">
<dt>Args:</dt><dd><p>group (str): name of a group in HDF5 file
show (bool): determines if matplotlib graph is created
and shown if True
origin (bool): determines if function should return raw data
save (bool): determines if matplotlib graph should be saved, saved graphs are TIFF files
colour_map_name (str) or (list): sets colours used to create graphs, valid options are returned by
Compound.colour_map staticmethod
xlim (tuple): tuple of two or one numbers that set corresponding axe limits
ylim (tuple): tuple of two or one numbers that set corresponding axe limits
xticks (int): frequency of x major ticks
yticks (int): frequency of x major ticks
field (‘B’ or ‘H’): chooses field type and unit: Tesla for B and kOe for H</p>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>if origin=True:</dt><dd><p>dict[origin_column (str), data (np.array)]: contains data used to create graph in origin</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.compound_object.Compound.plot_chitht">
<span class="sig-name descname"><span class="pre">plot_chitht</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colour_map_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'funmat'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xticks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yticks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'B'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.plot_chitht"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.compound_object.Compound.plot_chitht" title="Link to this definition">#</a></dt>
<dd><p>Function that creates graphs of chiT(H,T) or chi(H,T) depending on content of HDF5 file, given name of the group
in HDF5 file, graphs can be optionally shown, saved, colour palettes can be changed. If origin=True it returns
data packed into a dictionary for exporting to Origin.</p>
<blockquote>
<div><dl class="simple">
<dt>Args:</dt><dd><p>group (str): name of a group in HDF5 file
show (bool): determines if matplotlib graph is created
and shown if True
origin (bool): determines if function should return raw data
save (bool): determines if matplotlib graph should be saved, saved graphs are TIFF files
colour_map_name (str): sets colours used to create graphs, valid options are returned by
Compound.colour_map staticmethod
xlim (tuple): tuple of two or one numbers that set corresponding axe limits
ylim (tuple): tuple of two or one numbers that set corresponding axe limits
xticks (int): frequency of x major ticks
yticks (int): frequency of x major ticks
field (‘B’ or ‘H’): chooses field type and unit: Tesla for B and kOe for H</p>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>if origin=True:</dt><dd><p>dict[origin_column (str), data (np.array)]: contains data used to create graph in origin</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.compound_object.Compound.plot_hemholtz_energyth">
<span class="sig-name descname"><span class="pre">plot_hemholtz_energyth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">internal_energy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colour_map_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'rainbow'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xticks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yticks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'B'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.plot_hemholtz_energyth"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.compound_object.Compound.plot_hemholtz_energyth" title="Link to this definition">#</a></dt>
<dd><p>Function that creates graphs of M(H,T) given name of the group in HDF5 file, graphs can be optionally shown,
saved, colour palettes can be changed. If origin=True it returns data packed into a dictionary for exporting
to Origin.</p>
<blockquote>
<div><dl class="simple">
<dt>Args:</dt><dd><p>group (str): name of a group in HDF5 file
show (bool): determines if matplotlib graph is created
and shown if True
origin (bool): determines if function should return raw data
save (bool): determines if matplotlib graph should be saved, saved graphs are TIFF files
colour_map_name (str) or (list): sets colours used to create graphs, valid options are returned by
Compound.colour_map staticmethod
xlim (tuple): tuple of two or one numbers that set corresponding axe limits
ylim (tuple): tuple of two or one numbers that set corresponding axe limits
xticks (int): frequency of x major ticks
yticks (int): frequency of x major ticks
field (‘B’ or ‘H’): chooses field type and unit: Tesla for B and kOe for H</p>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>if origin=True:</dt><dd><p>dict[origin_column (str), data (np.array)]: contains data used to create graph in origin</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.compound_object.Compound.plot_zeeman">
<span class="sig-name descname"><span class="pre">plot_zeeman</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colour_map_name1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'BuPi'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colour_map_name2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'BuPi_r'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">single</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xticks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yticks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'B'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.plot_zeeman"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.compound_object.Compound.plot_zeeman" title="Link to this definition">#</a></dt>
<dd><p>Function that creates graphs of E(H,orientation) given name of the group in HDF5 file, graphs can be optionally shown,
saved, colour palettes can be changed. If origin=True it returns data packed into a dictionary for exporting
to Origin.</p>
<blockquote>
<div><dl class="simple">
<dt>Args:</dt><dd><p>group (str): name of a group in HDF5 file
show (bool): determines if matplotlib graph is created
and shown if True
origin (bool): determines if function should return raw data
save (bool): determines if matplotlib graph should be saved, saved graphs are TIFF files
colour_map_name1 (str) or (list): sets colours used to create graphs, valid options are returned by
Compound.colour_map staticmethod
colour_map_name2 (str) or (list): sets colours used to create graphs, valid options are returned by
Compound.colour_map staticmethod
single (bool): determines if graph should be created for each orientation given separately
xlim (tuple): tuple of two or one numbers that set corresponding axe limits
ylim (tuple): tuple of two or one numbers that set corresponding axe limits
xticks (int): frequency of x major ticks
yticks (int): frequency of y major ticks
field (‘B’ or ‘H’): chooses field type and unit: Tesla for B and kOe for H</p>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>if origin=True:</dt><dd><p>dict[origin_column (str), data (np.array)]: contains data used to create graph in origin</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.compound_object.Compound.plot_3d">
<span class="sig-name descname"><span class="pre">plot_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field_i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temp_i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colour_map_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dark_rainbow_r_l'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lim_scalar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ticks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_density</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_density</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis_off</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.plot_3d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.compound_object.Compound.plot_3d" title="Link to this definition">#</a></dt>
<dd><p>Function that creates 3d plots of data dependent on field (B[T]) and temperature(T[K])</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – name of a group from hdf5 file for which plot will be created</p></li>
<li><p><strong>data_type</strong> (<em>str</em>) – type of data that will be used to create plot, can only be one from 3 types: susceptibility,
hemholtz_energy or magnetisation</p></li>
<li><p><strong>field_i</strong> (<em>int</em>) – index of field from dataset that will be used for plot</p></li>
<li><p><strong>temp_i</strong> (<em>int</em>) – index of temperature from dataset that will be used for plot</p></li>
<li><p><strong>show</strong> (<em>bool = True</em>) – determines if plot is shown, currently there is no reason to setting it to False</p></li>
<li><p><strong>save</strong> (<em>bool = False</em>) – determines if plot is saved, name of the file will be in following format: f’{group}_3d_{data_type}.tiff’</p></li>
<li><p><strong>colour_map_name</strong> (<em>str</em><em> or </em><em>list = 'dark_rainbow_r_l'</em>) – input of Compound.colour_map function</p></li>
<li><p><strong>lim_scalar</strong> (<em>float = 1.</em>) – scalar used to set limits of axes, smaller values magm</p></li>
<li><p><strong>ticks</strong> (<em>float = 1.</em>) – </p></li>
<li><p><strong>r_density</strong> (<em>int = 0</em>) – determines rcount of 3D plot</p></li>
<li><p><strong>c_density</strong> (<em>int = 0</em>) – determines ccount of 3D plot</p></li>
<li><p><strong>axis_off</strong> (<em>bool = False</em>) – determines if axes are turned off</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.compound_object.Compound.animate_3d">
<span class="sig-name descname"><span class="pre">animate_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">animation_variable</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i_start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i_end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">30</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i_constant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colour_map_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dark_rainbow_r_l'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lim_scalar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ticks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_density</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_density</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis_off</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dpi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bar_scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bar_colour_map_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dark_rainbow_r'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temp_rounding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field_rounding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.animate_3d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.compound_object.Compound.animate_3d" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.compound_object.Compound.interactive_plot_3d">
<span class="sig-name descname"><span class="pre">interactive_plot_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colour_map_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dark_rainbow_r'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T_slider_colour</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'#77f285'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B_slider_colour</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'#794285'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temp_bar_colour_map_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'BuRd'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field_bar_colour_map_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'BuPi'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lim_scalar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ticks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis_off</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.interactive_plot_3d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.compound_object.Compound.interactive_plot_3d" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-slothpy.core.creation_functions">
<span id="slothpy-core-creation-functions-module"></span><h2>slothpy.core.creation_functions module<a class="headerlink" href="#module-slothpy.core.creation_functions" title="Link to this heading">#</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="slothpy.core.creation_functions.compound_from_orca">
<span class="sig-prename descclassname"><span class="pre">slothpy.core.creation_functions.</span></span><span class="sig-name descname"><span class="pre">compound_from_orca</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">slt_filepath</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt_filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orca_filepath</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orca_filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pt2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#slothpy.core.compound_object.Compound" title="slothpy.core.compound_object.Compound"><span class="pre">Compound</span></a></span></span><a class="reference internal" href="_modules/slothpy/core/creation_functions.html#compound_from_orca"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.creation_functions.compound_from_orca" title="Link to this definition">#</a></dt>
<dd><p>Create a Compound from ORCA output file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>slt_filepath</strong> (<em>str</em>) – Path of existing .slt file or to which the resulting .slt file will be
saved.</p></li>
<li><p><strong>slt_filename</strong> (<em>str</em>) – Name of the .slt file to be created/accessed.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – Name of a group to which results of relativistic ab initio calculations
will be saved.</p></li>
<li><p><strong>orca_filepath</strong> (<em>str</em>) – Path to the ORCA output file.</p></li>
<li><p><strong>orca_filename</strong> (<em>str</em>) – Name of the ORCA output file.</p></li>
<li><p><strong>pt2</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True the results of CASPT2/NEVPT2 second-order perturbative
corrections will be loaded to the file., by default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of Compound class associated with the given .slt file, that
serves as an user interface, holding all the available methods.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#slothpy.core.compound_object.Compound" title="slothpy.core.compound_object.Compound">Compound</a></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>SltFileError</strong> – If the program is unable to create a Compound from given files.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="slothpy.core.creation_functions.compound_from_molcas">
<span class="sig-prename descclassname"><span class="pre">slothpy.core.creation_functions.</span></span><span class="sig-name descname"><span class="pre">compound_from_molcas</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">slt_filepath</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt_filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">molcas_filepath</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">molcas_filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#slothpy.core.compound_object.Compound" title="slothpy.core.compound_object.Compound"><span class="pre">Compound</span></a></span></span><a class="reference internal" href="_modules/slothpy/core/creation_functions.html#compound_from_molcas"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.creation_functions.compound_from_molcas" title="Link to this definition">#</a></dt>
<dd><p>Create a Compound from MOLCAS rassi.h5 file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>slt_filepath</strong> (<em>str</em>) – Path of existing .slt file or to which the resulting .slt file will be
saved.</p></li>
<li><p><strong>slt_filename</strong> (<em>str</em>) – Name of the .slt file to be created/accessed.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – Name of a group to which results of relativistic ab initio calculations
will be saved.</p></li>
<li><p><strong>molcas_filepath</strong> (<em>str</em>) – Path to the MOLCAS .rassi.h5 file.</p></li>
<li><p><strong>molcas_filename</strong> (<em>str</em>) – Name of the MOLCAS .rassi.h5 file (without the suffix).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of Compound class associated with the given .slt file, that
serves as an user interface, holding all the available methods.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#slothpy.core.compound_object.Compound" title="slothpy.core.compound_object.Compound">Compound</a></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>SltFileError</strong> – If the program is unable to create a Compound from given files.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="slothpy.core.creation_functions.compound_from_slt">
<span class="sig-prename descclassname"><span class="pre">slothpy.core.creation_functions.</span></span><span class="sig-name descname"><span class="pre">compound_from_slt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">slt_filepath</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt_filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#slothpy.core.compound_object.Compound" title="slothpy.core.compound_object.Compound"><span class="pre">Compound</span></a></span></span><a class="reference internal" href="_modules/slothpy/core/creation_functions.html#compound_from_slt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.creation_functions.compound_from_slt" title="Link to this definition">#</a></dt>
<dd><p>Create a Compound from the existing .slt file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>slt_filepath</strong> (<em>str</em>) – Path to the existing .slt file to be loaded.</p></li>
<li><p><strong>slt_filename</strong> (<em>str</em>) – Name of an existing .slt file to be loaded.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of Compound class associated with the given .slt file, that
serves as an user interface, holding all the available methods.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#slothpy.core.compound_object.Compound" title="slothpy.core.compound_object.Compound">Compound</a></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>SltFileError</strong> – If the program is unable to create a Compound from a given file.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-slothpy.core">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-slothpy.core" title="Link to this heading">#</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="slothpy.core.compound_from_slt">
<span class="sig-prename descclassname"><span class="pre">slothpy.core.</span></span><span class="sig-name descname"><span class="pre">compound_from_slt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">slt_filepath</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt_filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#slothpy.core.compound_object.Compound" title="slothpy.core.compound_object.Compound"><span class="pre">Compound</span></a></span></span><a class="reference internal" href="_modules/slothpy/core/creation_functions.html#compound_from_slt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.compound_from_slt" title="Link to this definition">#</a></dt>
<dd><p>Create a Compound from the existing .slt file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>slt_filepath</strong> (<em>str</em>) – Path to the existing .slt file to be loaded.</p></li>
<li><p><strong>slt_filename</strong> (<em>str</em>) – Name of an existing .slt file to be loaded.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of Compound class associated with the given .slt file, that
serves as an user interface, holding all the available methods.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#slothpy.core.Compound" title="slothpy.core.Compound">Compound</a></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>SltFileError</strong> – If the program is unable to create a Compound from a given file.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="slothpy.core.compound_from_molcas">
<span class="sig-prename descclassname"><span class="pre">slothpy.core.</span></span><span class="sig-name descname"><span class="pre">compound_from_molcas</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">slt_filepath</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt_filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">molcas_filepath</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">molcas_filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#slothpy.core.compound_object.Compound" title="slothpy.core.compound_object.Compound"><span class="pre">Compound</span></a></span></span><a class="reference internal" href="_modules/slothpy/core/creation_functions.html#compound_from_molcas"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.compound_from_molcas" title="Link to this definition">#</a></dt>
<dd><p>Create a Compound from MOLCAS rassi.h5 file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>slt_filepath</strong> (<em>str</em>) – Path of existing .slt file or to which the resulting .slt file will be
saved.</p></li>
<li><p><strong>slt_filename</strong> (<em>str</em>) – Name of the .slt file to be created/accessed.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – Name of a group to which results of relativistic ab initio calculations
will be saved.</p></li>
<li><p><strong>molcas_filepath</strong> (<em>str</em>) – Path to the MOLCAS .rassi.h5 file.</p></li>
<li><p><strong>molcas_filename</strong> (<em>str</em>) – Name of the MOLCAS .rassi.h5 file (without the suffix).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of Compound class associated with the given .slt file, that
serves as an user interface, holding all the available methods.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#slothpy.core.Compound" title="slothpy.core.Compound">Compound</a></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>SltFileError</strong> – If the program is unable to create a Compound from given files.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="slothpy.core.compound_from_orca">
<span class="sig-prename descclassname"><span class="pre">slothpy.core.</span></span><span class="sig-name descname"><span class="pre">compound_from_orca</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">slt_filepath</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt_filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orca_filepath</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orca_filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pt2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#slothpy.core.compound_object.Compound" title="slothpy.core.compound_object.Compound"><span class="pre">Compound</span></a></span></span><a class="reference internal" href="_modules/slothpy/core/creation_functions.html#compound_from_orca"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.compound_from_orca" title="Link to this definition">#</a></dt>
<dd><p>Create a Compound from ORCA output file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>slt_filepath</strong> (<em>str</em>) – Path of existing .slt file or to which the resulting .slt file will be
saved.</p></li>
<li><p><strong>slt_filename</strong> (<em>str</em>) – Name of the .slt file to be created/accessed.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – Name of a group to which results of relativistic ab initio calculations
will be saved.</p></li>
<li><p><strong>orca_filepath</strong> (<em>str</em>) – Path to the ORCA output file.</p></li>
<li><p><strong>orca_filename</strong> (<em>str</em>) – Name of the ORCA output file.</p></li>
<li><p><strong>pt2</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True the results of CASPT2/NEVPT2 second-order perturbative
corrections will be loaded to the file., by default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An instance of Compound class associated with the given .slt file, that
serves as an user interface, holding all the available methods.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#slothpy.core.Compound" title="slothpy.core.Compound">Compound</a></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>SltFileError</strong> – If the program is unable to create a Compound from given files.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="slothpy.core.Compound">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">slothpy.core.</span></span><span class="sig-name descname"><span class="pre">Compound</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.Compound" title="Link to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The core object constituting the API and access to all the methods.</p>
<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.Compound.delete_group_dataset">
<span class="sig-name descname"><span class="pre">delete_group_dataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">first</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.delete_group_dataset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.Compound.delete_group_dataset" title="Link to this definition">#</a></dt>
<dd><p>Deletes a group/dataset provided its full name/path from the .slt file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>first</strong> (<em>str</em>) – A name of the gorup or dataset to be deleted.</p></li>
<li><p><strong>second</strong> (<em>str</em><em>, </em><em>optional</em>) – A name of the particular dataset inside the group from the first
argument to be deleted.</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>SltFileError</strong> – If the deletion is unsuccessful.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.Compound.calculate_g_tensor_and_axes_doublet">
<span class="sig-name descname"><span class="pre">calculate_g_tensor_and_axes_doublet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">doublets</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">int64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.calculate_g_tensor_and_axes_doublet"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.Compound.calculate_g_tensor_and_axes_doublet" title="Link to this definition">#</a></dt>
<dd><p>Calculates pseudo-g-tensor components (for S = 1/2) and
main magnetic axes for a given list of doublet states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for the computation of g-tensors.</p></li>
<li><p><strong>doublets</strong> (<em>ndarray</em><em>[</em><em>int64</em><em>]</em>) – ArrayLike structure (can be converted to numpy.NDArray) of integers
corresponding to doublet labels (numbers).</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given, the results will be saved using this name to the .slt
file with the suffix: _g_tensors_axes, by default None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The first array (g_tensor_list) contains a list g-tensors in
a format [doublet_number, gx, gy, gz], the second one
(magnetic_axes_list) contains respective rotation matrices.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Tuple[ndarray[float64], ndarray[float64]]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltInputError</strong> – If input ArrayLike data cannot be converted to numpy.NDArrays.</p></li>
<li><p><strong>SltInputError</strong> – If doublets are not one-diemsional array.</p></li>
<li><p><strong>SltCompError</strong> – If the calculation of g-tensors is unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Magnetic axes are returned in the form of rotation matrices that
diagonalise the Abragam-Bleaney tensor (G = gg.T). Coordinates of the
main axes XYZ in the initial xzy frame are columns of such matrices
(0-X, 1-Y, 2-Z).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.Compound.calculate_mth">
<span class="sig-name descname"><span class="pre">calculate_mth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fields</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperatures</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states_cutoff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_cpu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">autotune</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_autotune_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.calculate_mth"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.Compound.calculate_mth" title="Link to this definition">#</a></dt>
<dd><p>Calculates powder-averaged or directional molar magnetisation M(T,H)
for a given list of temperature and field values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for the computation of the magnetisation.</p></li>
<li><p><strong>fields</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – ArrayLike structure (can be converted to numpy.NDArray) of field
values (T) at which magnetisation will be computed.</p></li>
<li><p><strong>grid</strong> (<em>Union</em><em>[</em><em>int</em><em>, </em><em>ndarray</em><em>[</em><em>float64</em><em>]</em><em>]</em>) – If the grid is set to an integer from 0-11 then the prescribed
Lebedev-Laikov grids over hemisphere will be used (see
grids_over_hemisphere documentation), otherwise, user can provide
an ArrayLike structure (can be converted to numpy.NDArray) with the
convention: [[direction_x, direction_y, direction_z, weight],…]
for powder-averaging. If one wants a calculation for a single,
particular direction the list has to contain one entry like this:
[[direction_x, direction_y, direction_z, 1.]]. Custom grids will be
automatically normalized.</p></li>
<li><p><strong>temperatures</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – ArrayLike structure (can be converted to numpy.NDArray) of
temeperature values (K) at which magnetisation will be computed.</p></li>
<li><p><strong>states_cutoff</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of states that will be taken into account for construction
of Zeeman Hamiltonian. If set to zero, all available states from
the file will be used., by default 0</p></li>
<li><p><strong>number_cpu</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of logical CPUs to be assigned to perform the calculation.
If set to zero, all available CPUs will be used., by default 0</p></li>
<li><p><strong>number_threads</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of threads used in a multithreaded implementation of linear
algebra libraries used during the calculation. Higher values
benefit from the increasing size of matrices (states_cutoff) over
the parallelization over CPUs., by default 1</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _magnetisation., by default None</p></li>
<li><p><strong>autotune</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True the program will automatically try to choose the best
number of threads (and therefore parallel processes), for the given
number of CPUs, to be used during the calculation. Note that this
process can take a significant amount of time, so start to use it
with medium-sized calculations (e.g. for states_cutoff &gt; 300 with
dense grids or a higher number of field values) where it becomes
a necessity., by default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting mth_array gives magnetisation in Bohr magnetons and
is in the form [temperatures, fields] - the first dimension runs
over temperature values, and the second over fields.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray[float64]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltInputError</strong> – If input ArrayLike data cannot be converted to numpy.NDArrays.</p></li>
<li><p><strong>SltInputError</strong> – If fields are not a one-diemsional array.</p></li>
<li><p><strong>SltInputError</strong> – If temperatures are not a one-diemsional array.</p></li>
<li><p><strong>SltCompError</strong> – If autotuning a number of processes and threads is unsuccessful.</p></li>
<li><p><strong>SltCompError</strong> – If the calculation of magnetisation is unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">slothpy.lebedev_laikov_grid</span></code></dt><dd><p>For the description of the prescribed</p>
</dd>
</dl>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Lebedev-Laikov</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>Here, (number_cpu // number_threads) parallel processes are used to
distribute the workload over the provided field values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.Compound.calculate_mag_3d">
<span class="sig-name descname"><span class="pre">calculate_mag_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fields</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spherical_grid</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperatures</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states_cutoff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_cpu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">autotune</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_autotune_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.calculate_mag_3d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.Compound.calculate_mag_3d" title="Link to this definition">#</a></dt>
<dd><p>Calculates 3D magnetisation over a spherical grid for a given list of
temperature and field values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for the computation of the 3D magnetisation.</p></li>
<li><p><strong>fields</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – ArrayLike structure (can be converted to numpy.NDArray) of field
values (T) at which 3D magnetisation will be computed.</p></li>
<li><p><strong>spherical_grid</strong> (<em>int</em>) – Controls the density of the angular grid for the 3D magnetisation
calculation. A grid of dimension (spherical_grid*2*spherical_grid)
for spherical angles theta [0, pi], and phi [0, 2*pi] will be used.</p></li>
<li><p><strong>temperatures</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – ArrayLike structure (can be converted to numpy.NDArray) of
temperature values (K) at which 3D magnetisation will be computed.</p></li>
<li><p><strong>states_cutoff</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of states that will be taken into account for construction
of Zeeman Hamiltonian. If set to zero, all available states from
the file will be used., by default 0</p></li>
<li><p><strong>number_cpu</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of logical CPUs to be assigned to perform the calculation.
If set to zero, all available CPUs will be used., by default 0</p></li>
<li><p><strong>number_threads</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of threads used in a multithreaded implementation of linear
algebra libraries used during the calculation. Higher values
benefit from the increasing size of matrices (states_cutoff) over
the parallelization over CPUs., by default 1</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _3d_magnetisation., by default None</p></li>
<li><p><strong>autotune</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True the program will automatically try to choose the best
number of threads (and therefore parallel processes), for the given
number of CPUs, to be used during the calculation. Note that this
process can take a significant amount of time, so start to use it
with medium-sized calculations (e.g. for states_cutoff &gt; 300 with
dense grids or a higher number of field values) where it becomes
a necessity., by default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting mag_3d_array gives magnetisation in Bohr magnetons
and is in the form [coordinates, fields, temperatures, mesh, mesh]
- the first dimension runs over coordinates (0-x, 1-y, 2-z), the
second over field values, and the third over temperatures. The last
two dimensions are in a form of meshgrids over theta and phi, ready
for 3D plots as xyz.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray[float64]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltInputError</strong> – If input ArrayLike data cannot be converted to numpy.NDArrays.</p></li>
<li><p><strong>SltInputError</strong> – If fields are not a one-diemsional array.</p></li>
<li><p><strong>SltInputError</strong> – If temperatures are not a one-diemsional array.</p></li>
<li><p><strong>SltInputError</strong> – If spherical_grid is not a positive integer.</p></li>
<li><p><strong>SltCompError</strong> – If autotuning a number of processes and threads is unsuccessful.</p></li>
<li><p><strong>SltCompError</strong> – If the calculation of 3D magnetisation is unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Here, (number_cpu // number_threads) parallel processes are used to
distribute the workload over len(fields)*2*shperical_grid**2 tasks. Be
aware that the resulting arrays and computations can quickly consume
much memory (e.g. for a calculation with 100 field values 1-10 T, 300
temperatures 1-300 K, and spherical_grid = 60, the resulting array will
take 3*100*300*2*60*60*8 bytes = 5.184 GB).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.Compound.calculate_chitht">
<span class="sig-name descname"><span class="pre">calculate_chitht</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperatures</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fields</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_h</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states_cutoff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_cpu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exp</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">autotune</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_autotune_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.calculate_chitht"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.Compound.calculate_chitht" title="Link to this definition">#</a></dt>
<dd><p>Calculates powder-averaged or directional molar magnetic susceptibility
chi(T)(H,T) for a given list of field and temperatures values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for the computation of the magnetisation.</p></li>
<li><p><strong>temperatures</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – ArrayLike structure (can be converted to numpy.NDArray) of
temeperature values (K) at which magnetic susceptibility will
be computed.</p></li>
<li><p><strong>fields</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – ArrayLike structure (can be converted to numpy.NDArray) of field
values (T) at which magnetic susceptibility will be computed.</p></li>
<li><p><strong>number_of_points</strong> (<em>int</em>) – Controls the number of points for numerical differentiation over
the magnetic field values using the finite difference method with
a symmetrical stencil. The total number of used points =
(2 * num_of_opints + 1), therefore 1 is a minimum value to obtain
the first derivative using 3 points - including the value at the
point at which the derivative is taken. In this regard, the value 0
triggers the experimentalist model for susceptibility.</p></li>
<li><p><strong>delta_h</strong> (<em>float64</em><em>, </em><em>optional</em>) – Value of field step used for numerical differentiation using finite
difference method. 0.0001 (T) = 1 Oe is recommended as a starting
point., by default 0.0001</p></li>
<li><p><strong>states_cutoff</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of states that will be taken into account for construction
of Zeeman Hamiltonian. If set to zero, all available states from
the file will be used., by default 0</p></li>
<li><p><strong>number_cpu</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of logical CPUs to be assigned to perform the calculation.
If set to zero, all available CPUs will be used., by default 0</p></li>
<li><p><strong>number_threads</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of threads used in a multithreaded implementation of linear
algebra libraries used during the calculation. Higher values
benefit from the increasing size of matrices (states_cutoff) over
the parallelization over CPUs., by default 1</p></li>
<li><p><strong>exp</strong> (<em>bool</em><em>, </em><em>optional</em>) – Turns on the experimentalist model for magnetic susceptibility.,
by default False</p></li>
<li><p><strong>T</strong> (<em>bool</em><em>, </em><em>optional</em>) – Results are returned as a product with temperature chiT(H,T).,
by default True</p></li>
<li><p><strong>grid</strong> (<em>Union</em><em>[</em><em>int</em><em>, </em><em>np.ndarray</em><em>[</em><em>float64</em><em>]</em><em>]</em><em>, </em><em>optional</em>) – If the grid is set to an integer from 0-11 then the prescribed
Lebedev-Laikov grids over the hemisphere will be used (see
grids_over_hemisphere documentation), otherwise, the user can
provide an ArrayLike structure (can be converted to numpy.NDArray)
with the convention: [[direction_x, direction_y, direction_z,
weight],…] for powder-averaging. If one wants a calculation for a
single, particular direction the list has to contain one entry like
this: [[direction_x, direction_y, direction_z, 1.]]. If not given
the average is taken over xyz directions, which is sufficient for a
second rank tensor. Custom grids will be automatically normalized.,
by default None</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _susceptibility., by default None</p></li>
<li><p><strong>autotune</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True the program will automatically try to choose the best
number of threads (and therefore parallel processes), for the given
number of CPUs, to be used during the calculation. Note that this
process can take a significant amount of time, so start to use it
with medium-sized calculations (e.g. for states_cutoff &gt; 300 with
a higher number of field values and number_of_points) where it
becomes a necessity., by default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting chitht_array gives magnetic susceptibility (or
product with temperature) in cm^3 (or * K) and is in the form
[fields, temperatures] - the first dimension runs over field
values, and the second over temperatures.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray[float64]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file</p></li>
<li><p><strong>SltInputError</strong> – If input ArrayLike data cannot be converted to numpy.NDArrays</p></li>
<li><p><strong>SltInputError</strong> – If temperatures are not a one-diemsional array.</p></li>
<li><p><strong>SltInputError</strong> – If fields are not a one-diemsional array.</p></li>
<li><p><strong>SltInputError</strong> – If the  number of points for finite difference method is not
    a possitive integer.</p></li>
<li><p><strong>SltInputError</strong> – If the field step for the finite difference method is not
    a possitive real number.</p></li>
<li><p><strong>SltCompError</strong> – If autotuning a number of processes and threads is unsuccessful.</p></li>
<li><p><strong>SltCompError</strong> – If the calculation of magnetic susceptibility is unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Here, (number_cpu // number_threads) parallel processes are used to
distribute the workload over fields.size*(2*number_of_points+1) tasks.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.Compound.calculate_chit_tensorht">
<span class="sig-name descname"><span class="pre">calculate_chit_tensorht</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperatures</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fields</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_h</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states_cutoff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_cpu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exp</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">autotune</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_autotune_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.calculate_chit_tensorht"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.Compound.calculate_chit_tensorht" title="Link to this definition">#</a></dt>
<dd><p>Calculates magnetic susceptibility chi(H,T) (Van Vleck) tensor for
a given list of field and temperature values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for the computation of the magnetisation.</p></li>
<li><p><strong>temperatures</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – ArrayLike structure (can be converted to numpy.NDArray) of
temeperature values (K) at which magnetic susceptibility tensor
will be computed.</p></li>
<li><p><strong>fields</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – ArrayLike structure (can be converted to numpy.NDArray) of field
values (T) at which magnetic susceptibility tensor will be
computed.</p></li>
<li><p><strong>number_of_points</strong> (<em>int</em>) – Controls the number of points for numerical differentiation over
the magnetic field values using the finite difference method with
a symmetrical stencil. The total number of used points =
(2 * num_of_opints + 1), therefore 1 is a minimum value to obtain
the first derivative using 3 points - including the value at the
point at which the derivative is taken. In this regard, the value 0
triggers the experimentalist model for susceptibility.</p></li>
<li><p><strong>delta_h</strong> (<em>float64</em><em>, </em><em>optional</em>) – Value of field step used for numerical differentiation using finite
difference method. 0.0001 (T) = 1 Oe is recommended as a starting
point., by default 0.0001,</p></li>
<li><p><strong>states_cutoff</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of states that will be taken into account for construction
of Zeeman Hamiltonian. If set to zero, all available states from
the file will be used., by default 0</p></li>
<li><p><strong>number_cpu</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of logical CPUs to be assigned to perform the calculation.
If set to zero, all available CPUs will be used., by default 0</p></li>
<li><p><strong>number_threads</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of threads used in a multithreaded implementation of linear
algebra libraries used during the calculation. Higher values
benefit from the increasing size of matrices (states_cutoff) over
the parallelization over CPUs., by default 1</p></li>
<li><p><strong>exp</strong> (<em>bool</em><em>, </em><em>optional</em>) – Turns on the experimentalist model for magnetic susceptibility.,
by default False</p></li>
<li><p><strong>T</strong> (<em>bool</em><em>, </em><em>optional</em>) – Results are returned as a product with temperature chiT(H,T).,
by default True</p></li>
<li><p><strong>rotation</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em><em>, </em><em>optional</em>) – A (3,3) orthogonal rotation matrix used to rotate momenta matrices.
Note that the inverse matrix has to be given to rotate the
reference frame instead., by default None</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _susceptibility_tensor., by default None</p></li>
<li><p><strong>autotune</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True the program will automatically try to choose the best
number of threads (and therefore parallel processes), for the given
number of CPUs, to be used during the calculation. Note that this
process can take a significant amount of time, so start to use it
with medium-sized calculations (e.g. for states_cutoff &gt; 500 with
a higher number of field values and number_of_points) where it
becomes a necessity., by default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting array gives magnetic susceptibility (Van Vleck)
tensors (or products with temperature) in cm^3 (or * K) and is in
the form [fields, temperatures, 3x3 tensor] - the first dimension
runs over field values, the second over temperatures, and the last
two accomodate 3x3 tensors.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray[float64]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file</p></li>
<li><p><strong>SltInputError</strong> – If input ArrayLike data cannot be converted to numpy.NDArrays</p></li>
<li><p><strong>SltInputError</strong> – If temperatures are not a one-diemsional array.</p></li>
<li><p><strong>SltInputError</strong> – If fields are not a one-diemsional array.</p></li>
<li><p><strong>SltInputError</strong> – If the  number of points for finite difference method is not
    a possitive integer</p></li>
<li><p><strong>SltInputError</strong> – If the field step for the finite difference method is not
    a possitive real number.</p></li>
<li><p><strong>SltCompError</strong> – If autotuning a number of processes and threads is unsuccessful.</p></li>
<li><p><strong>SltCompError</strong> – If the calculation of magnetic susceptibility tensor is
    unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Here, (number_cpu // number_threads) parallel processes are used to
distribute the workload over fields.size*(2*number_of_points+1) tasks.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.Compound.calculate_chit_3d">
<span class="sig-name descname"><span class="pre">calculate_chit_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperatures</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fields</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spherical_grid</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_h</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states_cutoff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_cpu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exp</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">autotune</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_autotune_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.calculate_chit_3d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.Compound.calculate_chit_3d" title="Link to this definition">#</a></dt>
<dd><p>Calculates 3D magnetic susceptibility over a spherical grid for a given
list of temperature and field values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for the computation of the 3D magnetic
susceptibility.</p></li>
<li><p><strong>temperatures</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – ArrayLike structure (can be converted to numpy.NDArray) of
temperature values (K) at which 3D magnetic susceptibility will be
computed.</p></li>
<li><p><strong>fields</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – ArrayLike structure (can be converted to numpy.NDArray) of field
values (T) at which 3D magnetic susceptibility will be computed.</p></li>
<li><p><strong>spherical_grid</strong> (<em>int</em>) – Controls the density of the angular grid for the 3D susceptibility
calculation. A grid of dimension (spherical_grid*2*spherical_grid)
for spherical angles theta [0, pi], and phi [0, 2*pi] will be used.</p></li>
<li><p><strong>number_of_points</strong> (<em>int</em>) – Controls the number of points for numerical differentiation over
the magnetic field values using the finite difference method with
a symmetrical stencil. The total number of used points =
(2 * num_of_opints + 1), therefore 1 is a minimum value to obtain
the first derivative using 3 points - including the value at the
point at which the derivative is taken. In this regard, the value 0
triggers the experimentalist model for susceptibility.</p></li>
<li><p><strong>delta_h</strong> (<em>float64</em><em>, </em><em>optional</em>) – Value of field step used for numerical differentiation using finite
difference method. 0.0001 (T) = 1 Oe is recommended as a starting
point., by default 0.0001</p></li>
<li><p><strong>states_cutoff</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of states that will be taken into account for construction
of Zeeman Hamiltonian. If set to zero, all available states from
the file will be used., by default 0</p></li>
<li><p><strong>number_cpu</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of logical CPUs to be assigned to perform the calculation.
If set to zero, all available CPUs will be used., by default 0</p></li>
<li><p><strong>number_threads</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of threads used in a multithreaded implementation of linear
algebra libraries used during the calculation. Higher values
benefit from the increasing size of matrices (states_cutoff) over
the parallelization over CPUs., by default 1</p></li>
<li><p><strong>exp</strong> (<em>bool</em><em>, </em><em>optional</em>) – Turns on the experimentalist model for magnetic susceptibility.,
by default False</p></li>
<li><p><strong>T</strong> (<em>bool</em><em>, </em><em>optional</em>) – Results are returned as a product with temperature chiT(H,T).,
by default True</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _3d_magnetisation., by default None</p></li>
<li><p><strong>autotune</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True the program will automatically try to choose the best
number of threads (and therefore parallel processes), for the given
number of CPUs, to be used during the calculation. Note that this
process can take a significant amount of time, so start to use it
with medium-sized calculations (e.g. for states_cutoff &gt; 300 with
dense grids or a higher number of field values) where it becomes
a necessity., by default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting chi_3d_array gives magnetic susceptibility (or
product with temperature) in cm^3 (or * K) and is in the form
[coordinates, fields, temperatures, mesh, mesh] - the first
dimension runs over coordinates (0-x, 1-y, 2-z), the second over
field values, and the third over temperatures. The last two
dimensions are in a form of meshgrids over theta and phi, ready
for 3D plots as xyz.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray[float64]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltInputError</strong> – If input ArrayLike data cannot be converted to numpy.NDArrays.</p></li>
<li><p><strong>SltInputError</strong> – If temperatures are not a one-diemsional array.</p></li>
<li><p><strong>SltInputError</strong> – If fields are not a one-diemsional array.</p></li>
<li><p><strong>SltInputError</strong> – If spherical_grid is not a positive integer.</p></li>
<li><p><strong>SltInputError</strong> – If the  number of points for finite difference method is not
    a possitive integer.</p></li>
<li><p><strong>SltInputError</strong> – If the field step for the finite difference method is not
    a possitive real number.</p></li>
<li><p><strong>SltCompError</strong> – If autotuning a number of processes and threads is unsuccessful.</p></li>
<li><p><strong>SltCompError</strong> – If the calculation of 3D magnetic susceptibility is unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Here, (number_cpu // number_threads) parallel processes are used to
distribute the workload over len(fields)*(2*number_of_points + 1)
<a href="#id3"><span class="problematic" id="id4">*</span></a>2*shperical_grid**2 tasks. Be aware that the resulting arrays and
computations can quickly consume much memory (e.g. for calculation with
100 field values 1-10 T, 300 temperatures 1-300 K, number_of_points=3,
and spherical_grid = 60, the intermediate array (before numerical
differentiation) will take 7*100*300*2*60*60*8 bytes = 12.096 GB).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.Compound.calculate_hemholtz_energyth">
<span class="sig-name descname"><span class="pre">calculate_hemholtz_energyth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fields</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperatures</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states_cutoff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_cpu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">internal_energy</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">autotune</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_autotune_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.calculate_hemholtz_energyth"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.Compound.calculate_hemholtz_energyth" title="Link to this definition">#</a></dt>
<dd><p>Calculates powder-averaged or directional Hemholtz (or internal) energy
for a given list of temperature and field values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for the computation of the energy.</p></li>
<li><p><strong>fields</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – ArrayLike structure (can be converted to numpy.NDArray) of field
values (T) at which energy will be computed.</p></li>
<li><p><strong>grid</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – If the grid is set to an integer from 0-11 then the prescribed
Lebedev-Laikov grids over hemisphere will be used (see
grids_over_hemisphere documentation), otherwise, user can provide
an ArrayLike structure (can be converted to numpy.NDArray) with the
convention: [[direction_x, direction_y, direction_z, weight],…]
for powder-averaging. If one wants a calculation for a single,
particular direction the list has to contain one entry like this:
[[direction_x, direction_y, direction_z, 1.]]. Custom grids will be
automatically normalized.</p></li>
<li><p><strong>temperatures</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – ArrayLike structure (can be converted to numpy.NDArray) of
temeperature values (K) at which energy will be computed</p></li>
<li><p><strong>states_cutoff</strong> (<em>int</em>) – Number of states that will be taken into account for construction
of Zeeman Hamiltonian. If set to zero, all available states from
the file will be used., by default 0</p></li>
<li><p><strong>number_cpu</strong> (<em>int</em>) – Number of logical CPUs to be assigned to perform the calculation.
If set to zero, all available CPUs will be used., by default 0</p></li>
<li><p><strong>number_threads</strong> (<em>int</em>) – Number of threads used in a multithreaded implementation of linear
algebra libraries used during the calculation. Higher values
benefit from the increasing size of matrices (states_cutoff) over
the parallelization over CPUs., by default 1</p></li>
<li><p><strong>internal_energy</strong> (<em>bool</em><em>, </em><em>optional</em>) – Turns on the calculation of internal energy., by default False</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _hemholtz_energy or _internal_energy., by default
None</p></li>
<li><p><strong>autotune</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True the program will automatically try to choose the best
number of threads (and therefore parallel processes), for the given
number of CPUs, to be used during the calculation. Note that this
process can take a significant amount of time, so start to use it
with medium-sized calculations (e.g. for states_cutoff &gt; 300 with
dense grids or a higher number of field values) where it becomes
a necessity., by default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting eth_array gives energy in cm-1 and is in the form
[temperatures, fields] - the first dimension runs over temperature
values, and the second over fields.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray[float64]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltInputError</strong> – If input ArrayLike data cannot be converted to numpy.NDArrays.</p></li>
<li><p><strong>SltInputError</strong> – If fields are not a one-diemsional array</p></li>
<li><p><strong>SltInputError</strong> – If temperatures are not a one-diemsional array</p></li>
<li><p><strong>SltCompError</strong> – If autotuning a number of processes and threads is unsuccessful.</p></li>
<li><p><strong>SltCompError</strong> – If the calculation of energy is unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">slothpy.lebedev_laikov_grid</span></code></dt><dd><p>For the description of the prescribed</p>
</dd>
</dl>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Lebedev-Laikov</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>Here, (number_cpu // number_threads) parallel processes are used to
distribute the workload over the provided field values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.Compound.calculate_hemholtz_energy_3d">
<span class="sig-name descname"><span class="pre">calculate_hemholtz_energy_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fields</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spherical_grid</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperatures</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states_cutoff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_cpu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">internal_energy</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">autotune</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_autotune_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.calculate_hemholtz_energy_3d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.Compound.calculate_hemholtz_energy_3d" title="Link to this definition">#</a></dt>
<dd><p>Calculates 3D Hemholtz (or internal) energy over a spherical grid for
a given list of temperature and field values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for the computation of the 3D energy.</p></li>
<li><p><strong>fields</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – ArrayLike structure (can be converted to numpy.NDArray) of field
values (T) at which 3D energy will be computed.</p></li>
<li><p><strong>spherical_grid</strong> (<em>int</em>) – Controls the density of the angular grid for the 3D magnetisation
calculation. A grid of dimension (spherical_grid*2*spherical_grid)
for spherical angles theta [0, pi], and phi [0, 2*pi] will be used.</p></li>
<li><p><strong>temperatures</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – ArrayLike structure (can be converted to numpy.NDArray) of
temperature values (K) at which 3D energy will be computed.</p></li>
<li><p><strong>states_cutoff</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of states that will be taken into account for construction
of Zeeman Hamiltonian. If set to zero, all available states from
the file will be used., by default 0,</p></li>
<li><p><strong>number_cpu</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of logical CPUs to be assigned to perform the calculation.
If set to zero, all available CPUs will be used., by default 0</p></li>
<li><p><strong>number_threads</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of threads used in a multithreaded implementation of linear
algebra libraries used during the calculation. Higher values
benefit from the increasing size of matrices (states_cutoff) over
the parallelization over CPUs., by default 1</p></li>
<li><p><strong>internal_energy</strong> (<em>bool</em><em>, </em><em>optional</em>) – Turns on the calculation of internal energy., by default False</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _3d_hemholtz_energy or _3d_internal_energy.,
by default None</p></li>
<li><p><strong>autotune</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True the program will automatically try to choose the best
number of threads (and therefore parallel processes), for the given
number of CPUs, to be used during the calculation. Note that this
process can take a significant amount of time, so start to use it
with medium-sized calculations (e.g. for states_cutoff &gt; 300 with
dense grids or a higher number of field values) where it becomes
a necessity., by default False</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting energy_3d_array gives energy in cm-1
and is in the form [coordinates, fields, temperatures, mesh, mesh]
- the first dimension runs over coordinates (0-x, 1-y, 2-z), the
second over field values, and the third over temperatures. The last
two dimensions are in a form of meshgrids over theta and phi, ready
for 3D plots as xyz.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray[float64]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltInputError</strong> – If input ArrayLike data cannot be converted to numpy.NDArrays.</p></li>
<li><p><strong>SltInputError</strong> – If fields are not a one-diemsional array.</p></li>
<li><p><strong>SltInputError</strong> – If temperatures are not a one-diemsional array.</p></li>
<li><p><strong>SltInputError</strong> – If spherical_grid is not a positive integer.</p></li>
<li><p><strong>SltCompError</strong> – If autotuning a number of processes and threads is unsuccessful.</p></li>
<li><p><strong>SltCompError</strong> – If the calculation of 3D energy is unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Here, (number_cpu // number_threads) parallel processes are used to
distribute the workload over len(fields)*2*shperical_grid**2 tasks. Be
aware that the resulting arrays and computations can quickly consume
much memory (e.g. for a calculation with 100 field values 1-10 T, 300
temperatures 1-300 K, and spherical_grid = 60, the resulting array will
take 3*100*300*2*60*60*8 bytes = 5.184 GB).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.Compound.calculate_zeeman_splitting">
<span class="sig-name descname"><span class="pre">calculate_zeeman_splitting</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_states</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fields</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states_cutoff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_cpu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">average</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">autotune</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_autotune_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.calculate_zeeman_splitting"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.Compound.calculate_zeeman_splitting" title="Link to this definition">#</a></dt>
<dd><p>Calculates directional or powder-averaged Zeeman splitting for a given
number of states and list of field values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for the computation of the Zeeman splitting.</p></li>
<li><p><strong>number_of_states</strong> (<em>int</em>) – Number of states whose energy splitting will be given in the
result array.</p></li>
<li><p><strong>fields</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – ArrayLike structure (can be converted to numpy.NDArray) of field
values (T) at which Zeeman splitting will be computed.</p></li>
<li><p><strong>grid</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – If the grid is set to an integer from 0-11 then the prescribed
Lebedev-Laikov grids over hemisphere will be used (see
grids_over_hemisphere documentation) and powder-averaging will be
turned on, otherwise, user can provide an ArrayLike structure (can
be converted to numpy.NDArray) with the convention: [[direction_x,
direction_y, direction_z, weight],…] with average = True for
powder-averaging. If one wants a calculation for a list of
particular directions the list has to follow the format:
[[direction_x, direction_y, direction_z],…]. Custom grids will be
automatically normalized.</p></li>
<li><p><strong>states_cutoff</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of states that will be taken into account for construction
of Zeeman Hamiltonian. If set to zero, all available states from
the file will be used., by default 0</p></li>
<li><p><strong>number_cpu</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of logical CPUs to be assigned to perform the calculation.
If set to zero, all available CPUs will be used., by default 0</p></li>
<li><p><strong>number_threads</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of threads used in a multithreaded implementation of linear
algebra libraries used during the calculation. Higher values
benefit from the increasing size of matrices (states_cutoff) over
the parallelization over CPUs., by default 1</p></li>
<li><p><strong>average</strong> (<em>bool</em><em>, </em><em>optional</em>) – Turns on powder-averaging using a list of directions and weights in
the form of ArrayLike structure: [[direction_x, direction_y,
direction_z, weight],…].</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _zeeman_splitting., by default None</p></li>
<li><p><strong>autotune</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True the program will automatically try to choose the best
number of threads (and therefore parallel processes), for the given
number of CPUs, to be used during the calculation. Note that this
process can take a significant amount of time, so start to use it
with medium-sized calculations (e.g. for states_cutoff &gt; 300 with
dense grids or a higher number of field values) where it becomes
a necessity., by default Falsee</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting array gives Zeeman splitting of number_of_states
energy levels in cm-1 for each direction (or average) in the form
[orientations, fields, energies] - the first dimension
runs over different orientations, the second over field values, and
the last gives energy of number_of_states states.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray[float64]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltInputError</strong> – If input ArrayLike data cannot be converted to numpy.NDArrays.</p></li>
<li><p><strong>SltInputError</strong> – If fields are not a one-diemsional array.</p></li>
<li><p><strong>SltInputError</strong> – If number of states is not a positive integer less or equal to the
    states cutoff.</p></li>
<li><p><strong>SltCompError</strong> – If autotuning a number of processes and threads is unsuccessful.</p></li>
<li><p><strong>SltCompError</strong> – If the calculation of Zeeman splitting is unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">slothpy.lebedev_laikov_grid</span></code></dt><dd><p>For the description of the prescribed</p>
</dd>
</dl>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Lebedev-Laikov</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>Here, (number_cpu // number_threads) parallel processes are used to
distribute the workload over the provided field values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.Compound.zeeman_matrix">
<span class="sig-name descname"><span class="pre">zeeman_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states_cutoff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fields</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientations</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">complex128</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.zeeman_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.Compound.zeeman_matrix" title="Link to this definition">#</a></dt>
<dd><p>Calculates Zeeman matrices for a given list of magnetic fields and
their orientations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for the computation of the Zeeman matrices.</p></li>
<li><p><strong>states_cutoff</strong> (<em>int</em>) – Number of states that will be taken into account for construction
of Zeeman Hamiltonian. If set to zero, all available states from
the file will be used., by default 0</p></li>
<li><p><strong>fields</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – ArrayLike structure (can be converted to numpy.NDArray) of field
values (T) for which Zeeman matrices will be computed.</p></li>
<li><p><strong>orientations</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – List (ArrayLike structure) of particular magnetic field directions
for which Zeeman matrices will be constructed. The list has to
follow the format: [[direction_x, direction_y, direction_z],…].
The vectors will be automatically normalized.</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _zeeman_matrix., by default None</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting array gives Zeeman matrices for each field value and
orientation in the form [fields, orientations, matrix, matrix] in
atomic units a.u. (Hartree).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray[complex128]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltInputError</strong> – If input ArrayLike data cannot be converted to numpy.NDArrays.</p></li>
<li><p><strong>SltInputError</strong> – If fields are not a one-diemsional array.</p></li>
<li><p><strong>SltCompError</strong> – If the calculation of Zeeman matrices is unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.Compound.soc_energies_cm_1">
<span class="sig-name descname"><span class="pre">soc_energies_cm_1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_states</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.soc_energies_cm_1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.Compound.soc_energies_cm_1" title="Link to this definition">#</a></dt>
<dd><p>Returns energies for the given number of first spin-orbit
states in cm-1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations.</p></li>
<li><p><strong>number_of_states</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of states whose energy will be returned. If set to zero, all
available states will be inculded., by default 0</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _soc_energies., by default None</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting array is one-dimensional and contains the energy of
first number_of_states states in cm-1.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray[float64]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltReadError</strong> – If the program is unable to get SOC energies from the .slt file.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.Compound.states_magnetic_momenta">
<span class="sig-name descname"><span class="pre">states_magnetic_momenta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.states_magnetic_momenta"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.Compound.states_magnetic_momenta" title="Link to this definition">#</a></dt>
<dd><p>Calculates magnetic momenta of a given list (or number) of SOC states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for the computation of the magnetic momenta.</p></li>
<li><p><strong>states</strong> (<em>Union</em><em>[</em><em>int</em><em>, </em><em>np.ndarray</em><em>[</em><em>int</em><em>]</em><em>]</em><em>, </em><em>optional</em>) – ArrayLike structure (can be converted to numpy.NDArray) of
states indexes for which magnetic momenta will be calculated. If
set to an integer it acts as a states cutoff (first n states will
be given). For all available states set it to zero., by default 0</p></li>
<li><p><strong>rotation</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em><em>, </em><em>optional</em>) – A (3,3) orthogonal rotation matrix used to rotate momenta matrices.
Note that the inverse matrix has to be given to rotate the
reference frame instead., by default None</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _states_magnetic_momenta., by default None</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting array is one-dimensional and contains the magnetic
momenta corresponding to the given states indexes in atomic units.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray[float64]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltInputError</strong> – If input ArrayLike data cannot be converted to numpy.NDArrays.</p></li>
<li><p><strong>SltCompError</strong> – If the calculation of magnetic momenta is unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.Compound.states_total_angular_momenta">
<span class="sig-name descname"><span class="pre">states_total_angular_momenta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.states_total_angular_momenta"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.Compound.states_total_angular_momenta" title="Link to this definition">#</a></dt>
<dd><p>Calculates total angular momenta of a given list (or number) of SOC
states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for the computation of the magnetic momenta.</p></li>
<li><p><strong>states</strong> (<em>Union</em><em>[</em><em>int</em><em>, </em><em>np.ndarray</em><em>[</em><em>int</em><em>]</em><em>]</em><em>, </em><em>optional</em>) – ArrayLike structure (can be converted to numpy.NDArray) of
states indexes for which total angular momenta will be calculated.
If set to an integer it acts as a states cutoff (first n states
will be given). For all available states set it to zero.
, by default 0</p></li>
<li><p><strong>rotation</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em><em>, </em><em>optional</em>) – A (3,3) orthogonal rotation matrix used to rotate momenta matrices.
Note that the inverse matrix has to be given to rotate the
reference frame instead., by default None</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _states_total_angular_momenta., by default None</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting array is one-dimensional and contains the total
angular momenta corresponding to the given states indexes in atomic
units.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray[float64]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltInputError</strong> – If input ArrayLike data cannot be converted to numpy.NDArrays.</p></li>
<li><p><strong>SltCompError</strong> – If the calculation of total angular momenta is unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.Compound.magnetic_momenta_matrix">
<span class="sig-name descname"><span class="pre">magnetic_momenta_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states_cutoff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">complex128</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.magnetic_momenta_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.Compound.magnetic_momenta_matrix" title="Link to this definition">#</a></dt>
<dd><p>Calculates magnetic momenta matrix for a given number of SOC states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for the computation of the magnetic momenta
matrix.</p></li>
<li><p><strong>states_cutoff</strong> (<em>np.ndarray</em><em>, </em><em>optional</em>) – Number of states that will be taken into account for construction
of the magnetic momenta matrix. If set to zero, all available
states from the file will be included., by default 0</p></li>
<li><p><strong>rotation</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em><em>, </em><em>optional</em>) – A (3,3) orthogonal rotation matrix used to rotate momenta matrices.
Note that the inverse matrix has to be given to rotate the
reference frame instead., by default None</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _magnetic_momenta_matrix., by default None</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting magnetic_momenta_matrix_array gives magnetic momenta
in atomic units and is in the form [coordinates, matrix, matrix]
- the first dimension runs over coordinates (0-x, 1-y, 2-z).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray[complex128]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltCompError</strong> – If the calculation of magetic momenta matrix is unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.Compound.total_angular_momenta_matrix">
<span class="sig-name descname"><span class="pre">total_angular_momenta_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states_cutoff</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">complex128</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.total_angular_momenta_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.Compound.total_angular_momenta_matrix" title="Link to this definition">#</a></dt>
<dd><p>Calculates total angular momenta matrix for a given number of SOC
states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for the computation of the total angular momenta
matrix.</p></li>
<li><p><strong>states_cutoff</strong> (<em>np.ndarray</em><em>, </em><em>optional</em>) – Number of states that will be taken into account for construction
of the total angular momenta matrix. If set to zero, all available
states from the file will be included., by default 0</p></li>
<li><p><strong>rotation</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em><em>, </em><em>optional</em>) – A (3,3) orthogonal rotation matrix used to rotate momenta matrices.
Note that the inverse matrix has to be given to rotate the
reference frame instead., by default None</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _total angular_momenta_matrix., by default None</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting total_angular_momenta_matrix_array gives total
angular momenta in atomic units and is in the form [coordinates,
matrix, matrix] - the first dimension runs over coordinates
(0-x, 1-y, 2-z).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray[complex128]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltCompError</strong> – If the calculation of total angular momenta matrix is unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.Compound.matrix_decomposition_in_z_pseudo_spin_basis">
<span class="sig-name descname"><span class="pre">matrix_decomposition_in_z_pseudo_spin_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">soc</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">zeeman</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pseudo_kind</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">magnetic</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">total_angular</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float64</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.matrix_decomposition_in_z_pseudo_spin_basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.Compound.matrix_decomposition_in_z_pseudo_spin_basis" title="Link to this definition">#</a></dt>
<dd><p>Calculates decomposition of a given matrix in “z” pseudo-spin basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for the construction of the matrix.</p></li>
<li><p><strong>matrix</strong> (<em>Union</em><em>[</em><em>&quot;soc&quot;</em><em>, </em><em>&quot;zeeman&quot;</em><em>]</em>) – Type of a matrix to be decomposed. Two options available: “soc” or
“zeeman”.</p></li>
<li><p><strong>pseudo_kind</strong> (<em>Union</em><em>[</em><em>&quot;magnetic&quot;</em><em>, </em><em>&quot;total_angular&quot;</em><em>]</em>) – Kind of a pseudo-spin basis. Two options available: “magnetic” or
“total_angular” for the decomposition in a particular basis.</p></li>
<li><p><strong>start_state</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of the first SOC state to be included., by default 0</p></li>
<li><p><strong>stop_state</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of the last SOC state to be included. If both start and stop
are set to zero all available states from the file will be used.
, by default 0</p></li>
<li><p><strong>rotation</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em><em>, </em><em>optional</em>) – A (3,3) orthogonal rotation matrix used to rotate momenta matrices.
Note that the inverse matrix has to be given to rotate the
reference frame instead., by default None</p></li>
<li><p><strong>field</strong> (<em>float64</em><em>, </em><em>optional</em>) – If matrix type = “zeeman” it controls a magnetic field value at
which Zeman matrix will be computed., by default None</p></li>
<li><p><strong>orientation</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em><em>, </em><em>optional</em>) – If matrix type = “zeeman” it controls the orientation of the
magnetic field and has to be in the form [direction_x, direction_y,
direction_z] and be an ArrayLike structure (can be converted to
numpy.NDArray)., by default None</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _magnetic/total_angular_decomposition.
, by default None</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting array gives decomposition in % where rows are
SOC/Zeeman states and columns are associated with pseudo spin basis
(from -Sz to Sz).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray[float64]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltCompError</strong> – If the decomposition of the matrix is unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.Compound.soc_crystal_field_parameters">
<span class="sig-name descname"><span class="pre">soc_crystal_field_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pseudo_kind</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">magnetic</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">total_angular</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">even_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">complex</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.soc_crystal_field_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.Compound.soc_crystal_field_parameters" title="Link to this definition">#</a></dt>
<dd><p>Calculates ITO decomposition (CFPs) of SOC matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for obtaining the SOC matrix.</p></li>
<li><p><strong>start_state</strong> (<em>int</em>) – Number of the first SOC state to be included.</p></li>
<li><p><strong>stop_state</strong> (<em>int</em>) – Number of the last SOC state to be included. If both start and stop
are set to zero all available states from the file will be used.</p></li>
<li><p><strong>order</strong> (<em>int</em>) – Order of the highest ITO (CFP) to be included in the decomposition.</p></li>
<li><p><strong>pseudo_kind</strong> (<em>Union</em><em>[</em><em>&quot;magnetic&quot;</em><em>, </em><em>&quot;total_angular&quot;</em><em>]</em>) – Kind of a pseudo-spin basis. Two options available: “magnetic” or
“total_angular” for the decomposition in a particular basis.</p></li>
<li><p><strong>even_order</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, only even order ITOs (CFPs) will be included in the
decomposition., by default True</p></li>
<li><p><strong>complex</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, instead of real ITOs (CFPs) complex ones will be given.,
by default False</p></li>
<li><p><strong>rotation</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em><em>, </em><em>optional</em>) – A (3,3) orthogonal rotation matrix used to rotate momenta matrices.
Note that the inverse matrix has to be given to rotate the
reference frame instead., by default None</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _soc_ito_decomposition., by default None</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting list gives CFP - B_k_q (ITO) in the form [k,q,B_k_q].</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltReadError</strong> – If the program is unable to read SOC matrix from the file.</p></li>
<li><p><strong>SltInputError</strong> – If the order exceeds 2S pseudo-spin value.</p></li>
<li><p><strong>SltCompError</strong> – If the ITO decomposition of the matrix is unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.Compound.zeeman_matrix_ito_decpomosition">
<span class="sig-name descname"><span class="pre">zeeman_matrix_ito_decpomosition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pseudo_kind</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">magnetic</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">total_angular</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">complex</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.zeeman_matrix_ito_decpomosition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.Compound.zeeman_matrix_ito_decpomosition" title="Link to this definition">#</a></dt>
<dd><p>Calculates ITO decomposition of Zeeman matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for obtaining the Zeeman matrix.</p></li>
<li><p><strong>start_state</strong> (<em>int</em>) – Number of the first Zeeman state to be included.</p></li>
<li><p><strong>stop_state</strong> (<em>int</em>) – Number of the last Zeeman state to be included. If both start and
stop are set to zero all available states from the file will be
used.</p></li>
<li><p><strong>field</strong> (<em>float64</em>) – Magnetic field value at which Zeman matrix will be computed.</p></li>
<li><p><strong>orientation</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em>) – Orientation of the magnetic field in the form of an ArrayLike
structure (can be converted to numpy.NDArray) [direction_x,
direction_y, direction_z].</p></li>
<li><p><strong>order</strong> (<em>int</em>) – Order of the highest ITO (CFP) to be included in the decomposition.</p></li>
<li><p><strong>pseudo_kind</strong> (<em>Union</em><em>[</em><em>&quot;magnetic&quot;</em><em>, </em><em>&quot;total_angular&quot;</em><em>]</em>) – Kind of a pseudo-spin basis. Two options available: “magnetic” or
“total_angular” for the decomposition in a particular basis.</p></li>
<li><p><strong>complex</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, instead of real ITOs (CFPs) complex ones will be given.,
by default False</p></li>
<li><p><strong>rotation</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em><em>, </em><em>optional</em>) – A (3,3) orthogonal rotation matrix used to rotate momenta matrices.
Note that the inverse matrix has to be given to rotate the
reference frame instead., by default None</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _zeeman_ito_decomposition., by default None</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting list gives ITOs - B_k_q in the form [k,q,B_k_q]</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltCompError</strong> – If the program is unable to calculate Zeeman matrix from the file.</p></li>
<li><p><strong>SltInputError</strong> – If the order exceeds 2S pseudo-spin value</p></li>
<li><p><strong>SltCompError</strong> – If the ITO decomposition of the matrix is unsuccessful</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.Compound.matrix_from_ito">
<span class="sig-name descname"><span class="pre">matrix_from_ito</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">full_group_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">complex</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dataset_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pseudo_spin</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float64</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">complex128</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.matrix_from_ito"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.Compound.matrix_from_ito" title="Link to this definition">#</a></dt>
<dd><p>Calculates matrix from a given ITO decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>full_group_name</strong> (<em>str</em>) – Full name of a group containing ITO decomposition.</p></li>
<li><p><strong>complex</strong> (<em>bool</em>) – Determines the type of ITOs in the dataset. If True, instead of
real ITOs complex ones will be used., by default False</p></li>
<li><p><strong>dataset_name</strong> (<em>str</em><em>, </em><em>optional</em>) – A custom name for a user-created dataset within the group that
contains list of B_k_q parameters in the form [k,q,B_k_q].,
by default None</p></li>
<li><p><strong>pseudo_spin</strong> (<em>float64</em><em>, </em><em>optional</em>) – Pseudo spin S value for the user-defined dataset., by default None</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _matrix_from_ito., by default None</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Matrix reconstructed from a given ITO list.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray[complex128]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltCompError</strong> – If the calculation of the matrix from ITOs is unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.Compound.soc_zeem_in_z_angular_magnetic_momentum_basis">
<span class="sig-name descname"><span class="pre">soc_zeem_in_z_angular_magnetic_momentum_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrix_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">soc</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">zeeman</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis_kind</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">magnetic</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">total_angular</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float64</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">complex128</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.soc_zeem_in_z_angular_magnetic_momentum_basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.Compound.soc_zeem_in_z_angular_magnetic_momentum_basis" title="Link to this definition">#</a></dt>
<dd><p>Calculates SOC or Zeeman matrix in “z” magnetic or total angular
momentum basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – Name of a group containing results of relativistic ab initio
calculations used for obtaining the SOC or Zeeman matrix.</p></li>
<li><p><strong>start_state</strong> (<em>int</em>) – Number of the first SOC state to be included.</p></li>
<li><p><strong>stop_state</strong> (<em>int</em>) – Number of the last SOC state to be included. If both start and stop
are set to zero all available states from the file will be used</p></li>
<li><p><strong>matrix_type</strong> (<em>Union</em><em>[</em><em>&quot;soc&quot;</em><em>, </em><em>&quot;zeeman&quot;</em><em>]</em>) – Type of a matrix to be decomposed. Two options available: “soc” or
“zeeman”.</p></li>
<li><p><strong>basis_kind</strong> (<em>Union</em><em>[</em><em>&quot;magnetic&quot;</em><em>, </em><em>&quot;total_angular&quot;</em><em>]</em>) – Kind of a basis. Two options available: “magnetic” or
“total_angular” for the decomposition in a particular basis</p></li>
<li><p><strong>rotation</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em><em>, </em><em>optional</em>) – A (3,3) orthogonal rotation matrix used to rotate momenta matrices.
Note that the inverse matrix has to be given to rotate the
reference frame instead., by default None</p></li>
<li><p><strong>field</strong> (<em>float64</em><em>, </em><em>optional</em>) – _description_, by default None</p></li>
<li><p><strong>orientation</strong> (<em>ndarray</em><em>[</em><em>float64</em><em>]</em><em>, </em><em>optional</em>) – Orientation of the magnetic field in the form of an ArrayLike
structure (can be converted to numpy.NDArray) [direction_x,
direction_y, direction_z]., by default None</p></li>
<li><p><strong>slt</strong> (<em>str</em><em>, </em><em>optional</em>) – If given the results will be saved in a group of this name to .slt
file with suffix: _{matrix_type}_matrix_in_{basis_kind}_basis.,
by default None</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Matrix in a given kind of basis.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray[complex128]</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>SltInputError</strong> – If an unsuported type of matrix or basis is provided.</p></li>
<li><p><strong>SltInputError</strong> – If there is no field value or orientation provided for Zeeman
    matrix.</p></li>
<li><p><strong>SltSaveError</strong> – If the name of the group already exists in the .slt file.</p></li>
<li><p><strong>SltCompError</strong> – If the calculation of a matrix in “z” basis is unsuccessful.</p></li>
<li><p><strong>SltFileError</strong> – If the program is unable to correctly save results to .slt file.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.Compound.colour_map">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">colour_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.colour_map"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.Compound.colour_map" title="Link to this definition">#</a></dt>
<dd><p>Creates matplotlib colour map object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> – (str or lst) one of defined names for colour maps: BuPi, rainbow, dark_rainbow, light_rainbow,</p></li>
<li><p><strong>light_rainbow_alt</strong> – </p></li>
<li><p><strong>BuOr</strong> – </p></li>
<li><p><strong>BuYl</strong> – </p></li>
<li><p><strong>BuRd</strong> – </p></li>
<li><p><strong>GnYl</strong> – </p></li>
<li><p><strong>PrOr</strong> – </p></li>
<li><p><strong>GnRd</strong> – </p></li>
<li><p><strong>funmat</strong> – </p></li>
<li><p><strong>NdCoN322bpdo</strong> – </p></li>
<li><p><strong>NdCoNO222bpdo</strong> – </p></li>
<li><p><strong>NdCoI22bpdo</strong> – </p></li>
</ul>
</dd>
</dl>
<p>:param :
:param viridis:
:param plasma:
:param inferno:
:param magma:
:param cividis or list of colour from which colour map will be created by:
:param interpolation of colours between ones on a list; for predefined names modifiers can be applyed: _l loops
:param the list in a way that it starts and ends with the same colour:
:param _r reverses the list:</p>
<p>Returns:</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.Compound.custom_colour_cycler">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">custom_colour_cycler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">number_of_colours</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.custom_colour_cycler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.Compound.custom_colour_cycler" title="Link to this definition">#</a></dt>
<dd><p>Creates colour cycler from two colour maps in alternating pattern, suitable for use in matplotlib plots.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>number_of_colours</strong> – (int) number of colour in cycle</p></li>
<li><p><strong>cmap1</strong> – (str or lst) colour map name or list of colours (valid input for Compoud.colour_map())</p></li>
<li><p><strong>cmap2</strong> – (str or lst) colour map name or list of colours (valid input for Compoud.colour_map())</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>cycler object created based on two input colourmaps</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.Compound.plot_mth">
<span class="sig-name descname"><span class="pre">plot_mth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colour_map_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'rainbow'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xticks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yticks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'B'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.plot_mth"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.Compound.plot_mth" title="Link to this definition">#</a></dt>
<dd><p>Function that creates graphs of M(H,T) given name of the group in HDF5 file, graphs can be optionally shown,
saved, colour palettes can be changed. If origin=True it returns data packed into a dictionary for exporting
to Origin.</p>
<blockquote>
<div><dl class="simple">
<dt>Args:</dt><dd><p>group (str): name of a group in HDF5 file
show (bool): determines if matplotlib graph is created
and shown if True
origin (bool): determines if function should return raw data
save (bool): determines if matplotlib graph should be saved, saved graphs are TIFF files
colour_map_name (str) or (list): sets colours used to create graphs, valid options are returned by
Compound.colour_map staticmethod
xlim (tuple): tuple of two or one numbers that set corresponding axe limits
ylim (tuple): tuple of two or one numbers that set corresponding axe limits
xticks (int): frequency of x major ticks
yticks (int): frequency of x major ticks
field (‘B’ or ‘H’): chooses field type and unit: Tesla for B and kOe for H</p>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>if origin=True:</dt><dd><p>dict[origin_column (str), data (np.array)]: contains data used to create graph in origin</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.Compound.plot_chitht">
<span class="sig-name descname"><span class="pre">plot_chitht</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colour_map_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'funmat'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xticks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yticks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'B'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.plot_chitht"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.Compound.plot_chitht" title="Link to this definition">#</a></dt>
<dd><p>Function that creates graphs of chiT(H,T) or chi(H,T) depending on content of HDF5 file, given name of the group
in HDF5 file, graphs can be optionally shown, saved, colour palettes can be changed. If origin=True it returns
data packed into a dictionary for exporting to Origin.</p>
<blockquote>
<div><dl class="simple">
<dt>Args:</dt><dd><p>group (str): name of a group in HDF5 file
show (bool): determines if matplotlib graph is created
and shown if True
origin (bool): determines if function should return raw data
save (bool): determines if matplotlib graph should be saved, saved graphs are TIFF files
colour_map_name (str): sets colours used to create graphs, valid options are returned by
Compound.colour_map staticmethod
xlim (tuple): tuple of two or one numbers that set corresponding axe limits
ylim (tuple): tuple of two or one numbers that set corresponding axe limits
xticks (int): frequency of x major ticks
yticks (int): frequency of x major ticks
field (‘B’ or ‘H’): chooses field type and unit: Tesla for B and kOe for H</p>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>if origin=True:</dt><dd><p>dict[origin_column (str), data (np.array)]: contains data used to create graph in origin</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.Compound.plot_hemholtz_energyth">
<span class="sig-name descname"><span class="pre">plot_hemholtz_energyth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">internal_energy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colour_map_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'rainbow'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xticks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yticks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'B'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.plot_hemholtz_energyth"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.Compound.plot_hemholtz_energyth" title="Link to this definition">#</a></dt>
<dd><p>Function that creates graphs of M(H,T) given name of the group in HDF5 file, graphs can be optionally shown,
saved, colour palettes can be changed. If origin=True it returns data packed into a dictionary for exporting
to Origin.</p>
<blockquote>
<div><dl class="simple">
<dt>Args:</dt><dd><p>group (str): name of a group in HDF5 file
show (bool): determines if matplotlib graph is created
and shown if True
origin (bool): determines if function should return raw data
save (bool): determines if matplotlib graph should be saved, saved graphs are TIFF files
colour_map_name (str) or (list): sets colours used to create graphs, valid options are returned by
Compound.colour_map staticmethod
xlim (tuple): tuple of two or one numbers that set corresponding axe limits
ylim (tuple): tuple of two or one numbers that set corresponding axe limits
xticks (int): frequency of x major ticks
yticks (int): frequency of x major ticks
field (‘B’ or ‘H’): chooses field type and unit: Tesla for B and kOe for H</p>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>if origin=True:</dt><dd><p>dict[origin_column (str), data (np.array)]: contains data used to create graph in origin</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.Compound.plot_zeeman">
<span class="sig-name descname"><span class="pre">plot_zeeman</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colour_map_name1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'BuPi'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colour_map_name2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'BuPi_r'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">single</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xticks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yticks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'B'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.plot_zeeman"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.Compound.plot_zeeman" title="Link to this definition">#</a></dt>
<dd><p>Function that creates graphs of E(H,orientation) given name of the group in HDF5 file, graphs can be optionally shown,
saved, colour palettes can be changed. If origin=True it returns data packed into a dictionary for exporting
to Origin.</p>
<blockquote>
<div><dl class="simple">
<dt>Args:</dt><dd><p>group (str): name of a group in HDF5 file
show (bool): determines if matplotlib graph is created
and shown if True
origin (bool): determines if function should return raw data
save (bool): determines if matplotlib graph should be saved, saved graphs are TIFF files
colour_map_name1 (str) or (list): sets colours used to create graphs, valid options are returned by
Compound.colour_map staticmethod
colour_map_name2 (str) or (list): sets colours used to create graphs, valid options are returned by
Compound.colour_map staticmethod
single (bool): determines if graph should be created for each orientation given separately
xlim (tuple): tuple of two or one numbers that set corresponding axe limits
ylim (tuple): tuple of two or one numbers that set corresponding axe limits
xticks (int): frequency of x major ticks
yticks (int): frequency of y major ticks
field (‘B’ or ‘H’): chooses field type and unit: Tesla for B and kOe for H</p>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>if origin=True:</dt><dd><p>dict[origin_column (str), data (np.array)]: contains data used to create graph in origin</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.Compound.plot_3d">
<span class="sig-name descname"><span class="pre">plot_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field_i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temp_i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colour_map_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dark_rainbow_r_l'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lim_scalar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ticks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_density</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_density</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis_off</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.plot_3d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.Compound.plot_3d" title="Link to this definition">#</a></dt>
<dd><p>Function that creates 3d plots of data dependent on field (B[T]) and temperature(T[K])</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>group</strong> (<em>str</em>) – name of a group from hdf5 file for which plot will be created</p></li>
<li><p><strong>data_type</strong> (<em>str</em>) – type of data that will be used to create plot, can only be one from 3 types: susceptibility,
hemholtz_energy or magnetisation</p></li>
<li><p><strong>field_i</strong> (<em>int</em>) – index of field from dataset that will be used for plot</p></li>
<li><p><strong>temp_i</strong> (<em>int</em>) – index of temperature from dataset that will be used for plot</p></li>
<li><p><strong>show</strong> (<em>bool = True</em>) – determines if plot is shown, currently there is no reason to setting it to False</p></li>
<li><p><strong>save</strong> (<em>bool = False</em>) – determines if plot is saved, name of the file will be in following format: f’{group}_3d_{data_type}.tiff’</p></li>
<li><p><strong>colour_map_name</strong> (<em>str</em><em> or </em><em>list = 'dark_rainbow_r_l'</em>) – input of Compound.colour_map function</p></li>
<li><p><strong>lim_scalar</strong> (<em>float = 1.</em>) – scalar used to set limits of axes, smaller values magm</p></li>
<li><p><strong>ticks</strong> (<em>float = 1.</em>) – </p></li>
<li><p><strong>r_density</strong> (<em>int = 0</em>) – determines rcount of 3D plot</p></li>
<li><p><strong>c_density</strong> (<em>int = 0</em>) – determines ccount of 3D plot</p></li>
<li><p><strong>axis_off</strong> (<em>bool = False</em>) – determines if axes are turned off</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.Compound.animate_3d">
<span class="sig-name descname"><span class="pre">animate_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">animation_variable</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i_start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i_end</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">30</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i_constant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colour_map_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dark_rainbow_r_l'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lim_scalar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ticks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_density</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_density</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis_off</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dpi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bar_scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bar_colour_map_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dark_rainbow_r'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temp_rounding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field_rounding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.animate_3d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.Compound.animate_3d" title="Link to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="slothpy.core.Compound.interactive_plot_3d">
<span class="sig-name descname"><span class="pre">interactive_plot_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">group</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colour_map_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dark_rainbow_r'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T_slider_colour</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'#77f285'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B_slider_colour</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'#794285'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temp_bar_colour_map_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'BuRd'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">field_bar_colour_map_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'BuPi'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lim_scalar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ticks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis_off</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/slothpy/core/compound_object.html#Compound.interactive_plot_3d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#slothpy.core.Compound.interactive_plot_3d" title="Link to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
</section>


                </article>
              
              
              
              
              
                <footer class="prev-next-footer">
                  <!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="slothpy.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">slothpy package</p>
      </div>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#submodules">Submodules</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-slothpy.core.compound_object">slothpy.core.compound_object module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.compound_object.Compound"><code class="docutils literal notranslate"><span class="pre">Compound</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.compound_object.Compound.delete_group_dataset"><code class="docutils literal notranslate"><span class="pre">Compound.delete_group_dataset()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.compound_object.Compound.calculate_g_tensor_and_axes_doublet"><code class="docutils literal notranslate"><span class="pre">Compound.calculate_g_tensor_and_axes_doublet()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.compound_object.Compound.calculate_mth"><code class="docutils literal notranslate"><span class="pre">Compound.calculate_mth()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.compound_object.Compound.calculate_mag_3d"><code class="docutils literal notranslate"><span class="pre">Compound.calculate_mag_3d()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.compound_object.Compound.calculate_chitht"><code class="docutils literal notranslate"><span class="pre">Compound.calculate_chitht()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.compound_object.Compound.calculate_chit_tensorht"><code class="docutils literal notranslate"><span class="pre">Compound.calculate_chit_tensorht()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.compound_object.Compound.calculate_chit_3d"><code class="docutils literal notranslate"><span class="pre">Compound.calculate_chit_3d()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.compound_object.Compound.calculate_hemholtz_energyth"><code class="docutils literal notranslate"><span class="pre">Compound.calculate_hemholtz_energyth()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.compound_object.Compound.calculate_hemholtz_energy_3d"><code class="docutils literal notranslate"><span class="pre">Compound.calculate_hemholtz_energy_3d()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.compound_object.Compound.calculate_zeeman_splitting"><code class="docutils literal notranslate"><span class="pre">Compound.calculate_zeeman_splitting()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.compound_object.Compound.zeeman_matrix"><code class="docutils literal notranslate"><span class="pre">Compound.zeeman_matrix()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.compound_object.Compound.soc_energies_cm_1"><code class="docutils literal notranslate"><span class="pre">Compound.soc_energies_cm_1()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.compound_object.Compound.states_magnetic_momenta"><code class="docutils literal notranslate"><span class="pre">Compound.states_magnetic_momenta()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.compound_object.Compound.states_total_angular_momenta"><code class="docutils literal notranslate"><span class="pre">Compound.states_total_angular_momenta()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.compound_object.Compound.magnetic_momenta_matrix"><code class="docutils literal notranslate"><span class="pre">Compound.magnetic_momenta_matrix()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.compound_object.Compound.total_angular_momenta_matrix"><code class="docutils literal notranslate"><span class="pre">Compound.total_angular_momenta_matrix()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.compound_object.Compound.matrix_decomposition_in_z_pseudo_spin_basis"><code class="docutils literal notranslate"><span class="pre">Compound.matrix_decomposition_in_z_pseudo_spin_basis()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.compound_object.Compound.soc_crystal_field_parameters"><code class="docutils literal notranslate"><span class="pre">Compound.soc_crystal_field_parameters()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.compound_object.Compound.zeeman_matrix_ito_decpomosition"><code class="docutils literal notranslate"><span class="pre">Compound.zeeman_matrix_ito_decpomosition()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.compound_object.Compound.matrix_from_ito"><code class="docutils literal notranslate"><span class="pre">Compound.matrix_from_ito()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.compound_object.Compound.soc_zeem_in_z_angular_magnetic_momentum_basis"><code class="docutils literal notranslate"><span class="pre">Compound.soc_zeem_in_z_angular_magnetic_momentum_basis()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.compound_object.Compound.colour_map"><code class="docutils literal notranslate"><span class="pre">Compound.colour_map()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.compound_object.Compound.custom_colour_cycler"><code class="docutils literal notranslate"><span class="pre">Compound.custom_colour_cycler()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.compound_object.Compound.plot_mth"><code class="docutils literal notranslate"><span class="pre">Compound.plot_mth()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.compound_object.Compound.plot_chitht"><code class="docutils literal notranslate"><span class="pre">Compound.plot_chitht()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.compound_object.Compound.plot_hemholtz_energyth"><code class="docutils literal notranslate"><span class="pre">Compound.plot_hemholtz_energyth()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.compound_object.Compound.plot_zeeman"><code class="docutils literal notranslate"><span class="pre">Compound.plot_zeeman()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.compound_object.Compound.plot_3d"><code class="docutils literal notranslate"><span class="pre">Compound.plot_3d()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.compound_object.Compound.animate_3d"><code class="docutils literal notranslate"><span class="pre">Compound.animate_3d()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.compound_object.Compound.interactive_plot_3d"><code class="docutils literal notranslate"><span class="pre">Compound.interactive_plot_3d()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-slothpy.core.creation_functions">slothpy.core.creation_functions module</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.creation_functions.compound_from_orca"><code class="docutils literal notranslate"><span class="pre">compound_from_orca()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.creation_functions.compound_from_molcas"><code class="docutils literal notranslate"><span class="pre">compound_from_molcas()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.creation_functions.compound_from_slt"><code class="docutils literal notranslate"><span class="pre">compound_from_slt()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-slothpy.core">Module contents</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.compound_from_slt"><code class="docutils literal notranslate"><span class="pre">compound_from_slt()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.compound_from_molcas"><code class="docutils literal notranslate"><span class="pre">compound_from_molcas()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.compound_from_orca"><code class="docutils literal notranslate"><span class="pre">compound_from_orca()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.Compound"><code class="docutils literal notranslate"><span class="pre">Compound</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.Compound.delete_group_dataset"><code class="docutils literal notranslate"><span class="pre">Compound.delete_group_dataset()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.Compound.calculate_g_tensor_and_axes_doublet"><code class="docutils literal notranslate"><span class="pre">Compound.calculate_g_tensor_and_axes_doublet()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.Compound.calculate_mth"><code class="docutils literal notranslate"><span class="pre">Compound.calculate_mth()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.Compound.calculate_mag_3d"><code class="docutils literal notranslate"><span class="pre">Compound.calculate_mag_3d()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.Compound.calculate_chitht"><code class="docutils literal notranslate"><span class="pre">Compound.calculate_chitht()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.Compound.calculate_chit_tensorht"><code class="docutils literal notranslate"><span class="pre">Compound.calculate_chit_tensorht()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.Compound.calculate_chit_3d"><code class="docutils literal notranslate"><span class="pre">Compound.calculate_chit_3d()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.Compound.calculate_hemholtz_energyth"><code class="docutils literal notranslate"><span class="pre">Compound.calculate_hemholtz_energyth()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.Compound.calculate_hemholtz_energy_3d"><code class="docutils literal notranslate"><span class="pre">Compound.calculate_hemholtz_energy_3d()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.Compound.calculate_zeeman_splitting"><code class="docutils literal notranslate"><span class="pre">Compound.calculate_zeeman_splitting()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.Compound.zeeman_matrix"><code class="docutils literal notranslate"><span class="pre">Compound.zeeman_matrix()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.Compound.soc_energies_cm_1"><code class="docutils literal notranslate"><span class="pre">Compound.soc_energies_cm_1()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.Compound.states_magnetic_momenta"><code class="docutils literal notranslate"><span class="pre">Compound.states_magnetic_momenta()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.Compound.states_total_angular_momenta"><code class="docutils literal notranslate"><span class="pre">Compound.states_total_angular_momenta()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.Compound.magnetic_momenta_matrix"><code class="docutils literal notranslate"><span class="pre">Compound.magnetic_momenta_matrix()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.Compound.total_angular_momenta_matrix"><code class="docutils literal notranslate"><span class="pre">Compound.total_angular_momenta_matrix()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.Compound.matrix_decomposition_in_z_pseudo_spin_basis"><code class="docutils literal notranslate"><span class="pre">Compound.matrix_decomposition_in_z_pseudo_spin_basis()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.Compound.soc_crystal_field_parameters"><code class="docutils literal notranslate"><span class="pre">Compound.soc_crystal_field_parameters()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.Compound.zeeman_matrix_ito_decpomosition"><code class="docutils literal notranslate"><span class="pre">Compound.zeeman_matrix_ito_decpomosition()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.Compound.matrix_from_ito"><code class="docutils literal notranslate"><span class="pre">Compound.matrix_from_ito()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.Compound.soc_zeem_in_z_angular_magnetic_momentum_basis"><code class="docutils literal notranslate"><span class="pre">Compound.soc_zeem_in_z_angular_magnetic_momentum_basis()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.Compound.colour_map"><code class="docutils literal notranslate"><span class="pre">Compound.colour_map()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.Compound.custom_colour_cycler"><code class="docutils literal notranslate"><span class="pre">Compound.custom_colour_cycler()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.Compound.plot_mth"><code class="docutils literal notranslate"><span class="pre">Compound.plot_mth()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.Compound.plot_chitht"><code class="docutils literal notranslate"><span class="pre">Compound.plot_chitht()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.Compound.plot_hemholtz_energyth"><code class="docutils literal notranslate"><span class="pre">Compound.plot_hemholtz_energyth()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.Compound.plot_zeeman"><code class="docutils literal notranslate"><span class="pre">Compound.plot_zeeman()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.Compound.plot_3d"><code class="docutils literal notranslate"><span class="pre">Compound.plot_3d()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.Compound.animate_3d"><code class="docutils literal notranslate"><span class="pre">Compound.animate_3d()</span></code></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#slothpy.core.Compound.interactive_plot_3d"><code class="docutils literal notranslate"><span class="pre">Compound.interactive_plot_3d()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
  </nav></div>

  <div class="sidebar-secondary-item">
  <div class="tocsection sourcelink">
    <a href="_sources/slothpy.core.rst.txt">
      <i class="fa-solid fa-file-lines"></i> Show Source
    </a>
  </div>
</div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=ac02cc09edc035673794"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=ac02cc09edc035673794"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">
  <p class="copyright">
    
      © Copyright 2023, Mikołaj Żychowicz.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">
  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item"><p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.14.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>